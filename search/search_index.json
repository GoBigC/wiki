{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About BigC","text":"<p>BigC is a compiled programming language that's not as big as C.</p> <ul> <li> <p>Language design choices</p> <ul> <li>A compiled language</li> <li>Compiles to RISC-V assembly</li> <li>Arguments are Pass-By-Value</li> <li>Compiler written in Go</li> </ul> </li> <li> <p>Tech stack</p> <ul> <li>ANTLR </li> <li>Go </li> <li>RISC-V assembly</li> </ul> </li> </ul>"},{"location":"contributing/","title":"Want to contribute to BigC?","text":"<p>It's all here, clone, fork, whatever you want! </p>"},{"location":"faq/","title":"FAQ","text":"<ol> <li> <p>Who are the authors? </p> <ul> <li>@siddankthep (Sid) - Farmer #1 </li> <li>@lanphgphm (LP) - Farmer #2</li> <li>@brokisd (Khoa) - Farmer #3</li> </ul> </li> <li> <p>Why? </p> </li> </ol> <p>N/A</p> <ol> <li>Why the broccoli logo? </li> </ol> <p>We were originally called \"TheBroccoliFarmers\", but had to change the organization's name due to practicality. </p> <ol> <li>Why BigC? </li> </ol> <p>Because we think it's funny. </p> <ol> <li>Useful facts? </li> <li>BigC compiles to bare-metal RISC-V assembly, which makes the language compliant with ZERO operating system</li> <li>This choice was made out of practicality: we are too silly to support OS compliance </li> </ol>"},{"location":"0-housekeeping/designChoices/","title":"BigC Is a Compiled Language","text":"<p>The choice to write a compiled language as opposed to an interpreted one is mostly because we wanted to write a compiler. </p> <p>As hardwares get more and more powerful, the previously slow execution time of a code snippet is hardly noticeable anymore. Languages that spawned recently are mostly compiled for this reason:</p> <p></p> <p>We think that we have significantly more chance to write interpreted languages in future work experiences, and we wanted to take this chance to know what it takes to write a compiled language. </p>"},{"location":"0-housekeeping/designChoices/#static-typing-static-scoping","title":"Static Typing &amp; Static Scoping","text":"<p>For safety and predictability, BigC requires explicit typing that will be checked during compilation. </p> <p>Dynamic scoping is generally not a good idea, though it makes things simpler for us language developers. Dynamically scoped languages like JavaScript or Bash are often used to write short scripts, and that is not the intended direction for BigC. </p>"},{"location":"0-housekeeping/designChoices/#targets-the-risc-v-isa","title":"Targets the RISC-V ISA","text":"<p>Compiling from a high-level language to another high-level language (like C or Java, or god forbid, Python) seems like cheating :) as if it is pseudo-compiling :) </p> <p>So to put ourselves to the challenge, we decided to compile our language to an assembly language. But to not make it too hard, we only write bare-metal assembly, which means bypassing the OS (like Linux), which means BigC does not cooperate with any operating system. </p> <p>So why RISC-V? </p> <p>It seems like a rising ISA and we want to know what's up :D It's also always a good use of time to learn assembly (right?)</p>"},{"location":"0-housekeeping/designChoices/#function-arguments-are-pass-by-value","title":"Function Arguments are Pass-By-Value","text":"<p>This choice was made out of practicality: Pass-By-Reference is hard :) and we believe that to do a good job at it, we need to know how to implement Pass-By-Value anyways. </p> <p>To get this project started, we were advised to only supports Pass-By-Value. </p>"},{"location":"0-housekeeping/designChoices/#compiler-written-in-go","title":"Compiler Written In Go","text":"<p>Because many companies are writing or even rewriting their tools in Go. Most recently Microsoft decided to write their TypeScript engine in Go (see here). </p> <p>And once again, we'd like to know why the language is so loved :)</p>"},{"location":"0-housekeeping/techStack/","title":"Why ANTLR?","text":"<p>If not ANTLR, we would be working with lex/yacc (flex/bison), which would generate C codes, and it takes an extra step to make that compatible with Go code. The general advice we see is that if we don't have to use lex/yacc (ie. maintaining a legacy compiler that uses these), then we should look for different tools(source1), (source2).</p> <p> </p> <p>Go has its own version of yacc called goyacc. It is very close to yacc, but native to Go. And by translation, the previous warnings about using lex/yacc still kinda applies. </p> <p>ANTLR is more modern and supports Go. ANTLR also supports the Visitor pattern out of the box. For this and the fact that people warns so much against lex/yacc, we made the decision to use ANTLR as BigC's parser generator.</p> <p>Since ANTLR is a LL-parser, we should make our grammar not left-recursive. See more in the ANTLR lexer document</p>"},{"location":"0-housekeeping/techStack/#why-go","title":"Why Go?","text":"<p>Because we want to. </p> <p>Actually, because recently Microsoft port their entire Typescript engine into Go, which is such a big egoless move, and we thought Go must be really good for people at Microsoft to do this. We too would like to know why Go is rising so fast. </p>"},{"location":"0-housekeeping/techStack/#why-risc-v","title":"Why RISC-V?","text":"<p>Because we want to. </p>"},{"location":"1-grammar/bible/","title":"BigC Full Grammar","text":"<p>You can also read this at the grammar repository.</p>"},{"location":"1-grammar/bible/#parser-rules","title":"Parser Rules","text":"<p>program     : declaration* EOF     ;</p> <p>declaration     : type Identifier arrayNotation? declarationRemainder     ;</p> <p>arrayNotation     : '[' expression ']'     ;</p> <p>type     : 'int'     | 'float'     | 'bool'     | 'char'     | 'void'      ;</p> <p>declarationRemainder      : '(' parameterList? ')' block      | variableInitializer? ';'     ;</p> <p>parameterList     : parameter (',' parameter)*     ;</p> <p>parameter     : type Identifier arrayNotation?     ;</p> <p>block      : '{' blockItem* '}'     ;</p> <p>blockItem     : declaration     | statement     ;</p> <p>statement     : ifStatement     | nonIfStatement     ;</p> <p>ifStatement     : 'if' '(' expression ')' block elseClause?     ;</p> <p>elseClause     : 'else' (block | ifStatement)     ;</p> <p>nonIfStatement      : expression ';'     | whileStatement     | returnStatement     ;</p> <p>whileStatement     : 'while' '(' expression ')' block      ;</p> <p>returnStatement      : 'return' expression ';'     ;</p> <p>// Expression precedence (from highest to lowest): // 1. Primary expressions (constants, variables, parenthesized)    // 2. Postfix operations (arr[i], fn(), x++, x--) -- only support the first 2  // 3. Unary operations (-x, !x, ++x, --x) -- only support the first two    // 4. Multiplicative (*, /)    // 5. Additive (+, -)  // 6. Comparison (&lt;, &lt;=, &gt;=, &gt;)    // 7. Equality (==, !=)    // 8. Logical AND (&amp;&amp;) // 9. Logical OR (||)  // 10. Assignment (=)   </p> <p>expression      : assignmentExpression      ;</p> <p>assignmentExpression     : logicalOrExpression assignmentRest?     ;</p> <p>assignmentRest     : '=' assignmentExpression     ;</p> <p>variableInitializer     : '=' expression     ;</p> <p>logicalOrExpression     : logicalAndExpression logicalOrRest*     ;</p> <p>logicalOrRest     : '||' logicalAndExpression     ;</p> <p>logicalAndExpression     : equalityExpression logicalAndRest*     ;</p> <p>logicalAndRest     : '&amp;&amp;' equalityExpression     ;</p> <p>equalityExpression     : comparisonExpression equalityRest*     ;</p> <p>equalityRest     : equalityOperator comparisonExpression     ;</p> <p>equalityOperator      : '=='     | '!='     ;</p> <p>comparisonExpression      : additionExpression comparisonRest*     ;</p> <p>comparisonRest     : comparisonOperator additionExpression     ;</p> <p>comparisonOperator     : '&gt;'     | '&lt;'     | '&gt;='     | '&lt;='     ;</p> <p>additionExpression     : multiplicationExpression additionExpressionRest*     ;</p> <p>additionExpressionRest     : addSubtractOperator multiplicationExpression     ;</p> <p>addSubtractOperator      : '+'     | '-'     ;</p> <p>multiplicationExpression     : unaryExpression multiplicationExpressionRest*     ;</p> <p>multiplicationExpressionRest     : multDivModOperator unaryExpression     ;</p> <p>multDivModOperator     : '*'     | '/'     ;</p> <p>unaryExpression      : postfixExpression      | unaryOperator unaryExpression      ;</p> <p>unaryOperator     : '!'     | '-'     ;</p> <p>postfixExpression      : primaryExpression (arrayAccess | functionCallArgs)?     ;</p> <p>arrayAccess      : '[' expression ']'     ;</p> <p>functionCallArgs     : '(' argList? ')'     ;</p> <p>argList      : assignmentExpression (',' assignmentExpression)*     ;</p> <p>primaryExpression      : Identifier      | constant      | '(' expression ')'     ;</p> <p>constant     : IntegerConstant      | FloatingConstant      | BooleanConstant      | CharConstant      ;</p>"},{"location":"1-grammar/bible/#lexer-rules","title":"Lexer Rules","text":"<p>BooleanConstant: 'true' | 'false'; CharConstant: '\\'' . '\\'';  </p> <p>Identifier: [a-zA-Z_][a-zA-Z0-9_]*; </p> <p>IntegerConstant: [0-9]+;   FloatingConstant: [0-9]+ '.' [0-9]+;    </p> <p>WS: [ \\t\\r\\n]+ -&gt; skip;    COMMENT: '//' ~[\\r\\n]* -&gt; skip;    MULTILINE_COMMENT: '/*' .*? '*/' -&gt; skip;   </p>"},{"location":"1-grammar/proof/","title":"Proof of Unambiguity","text":"<p>A grammar is considered unambiguous if it is LL(1) or LR(1), meaning the parser can determine the exact rule to apply next by examining only one token ahead in the input stream. In the same sense, the more tokens a parser needs to lookahead, the more ambiguous the grammar is. </p> <p>The proof of BigC's grammar unambiguity is therefore done by using ANTLR. ANTLR writes logs for each production rules it consume, and if the rule is unambiguous, it marks this rule to be <code>LL(1)? true</code>. When all rules/decisions in the grammar is marked like this, we say that the entire grammar is unambiguous. </p> <p>You can read the log here to verify that BigC has an unambiguous grammar: </p> <pre><code>DECISION 0 in rule program\n2025-04-07 16:01:03:482 LL1 LogManager.java:25 look=[{3..7}, &lt;EOF&gt;]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 1 in rule declaration\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[1, {8, 10, 18}]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 2 in rule declarationRemainder\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[{3..7}, 9]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 3 in rule declarationRemainder\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[18, 10]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 4 in rule declarationRemainder\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[8, {10, 18}]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 5 in rule parameterList\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[11, 9]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 6 in rule parameter\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[1, {9, 11}]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 7 in rule block\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[{3..8, 14, 16..17, 28, 31..36}, 13]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 8 in rule blockItem\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[{3..7}, {8, 14, 16..17, 28, 31..36}]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 9 in rule statement\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 look=[14, {8, 16..17, 28, 31..36}]\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 10 in rule ifStatement\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 look=[15, {3..8, 13..14, 16..17, 28, 31..36}]\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 11 in rule elseClause\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 look=[12, 14]\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 12 in rule nonIfStatement\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 look=[{8, 28, 31..36}, 16, 17]\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 13 in rule assignmentExpression\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 look=[18, {2, 9..11}]\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 14 in rule logicalOrExpression\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 look=[19, {2, 9..11, 18}]\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 15 in rule logicalAndExpression\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 look=[20, {2, 9..11, 18..19}]\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 16 in rule equalityExpression\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 look=[{21..22}, {2, 9..11, 18..20}]\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 17 in rule comparisonExpression\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 look=[{23..26}, {2, 9..11, 18..22}]\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 18 in rule additionExpression\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 look=[{27..28}, {2, 9..11, 18..26}]\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 19 in rule multiplicationExpression\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 look=[{29..30}, {2, 9..11, 18..28}]\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 20 in rule unaryExpression\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 look=[{8, 32..36}, {28, 31}]\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 21 in rule postfixExpression\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 look=[1, 8, {2, 9..11, 18..30}]\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 22 in rule functionCallArgs\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 look=[{8, 28, 31..36}, 9]\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 23 in rule argList\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 look=[11, 9]\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 24 in rule primaryExpression\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 look=[34, {32..33, 35..36}, 8]\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 LL(1)? true\n</code></pre>"},{"location":"1-grammar/sample/","title":"Sample BigC Code","text":"<p>See all sample code files in BigC repository. Here is one of such: </p> <pre><code>/* Comprehensive test file for BigC grammar */\n\n// Global variable declarations with all primitive types\nint globalInt = 42;\nfloat globalFloat = 3.14159;\nbool globalBool = true;\nchar globalChar = 'A';\nint globalInt2 = -16; \nfloat globalFloat2 = -1.2321;\n\n// Array declaration with size (syntax depends on your grammar rules)\nint globalArray[10];\n\n// Function to fill an array\nvoid fillArray(int arr[43], int value) {\n    int i = 0;\n    while (i &lt; 5) {\n        arr[i] = value;\n        i = i + 1;\n    }\n}\n\n// Function to sum array elements\nint sumArray(int arr[5]) {\n    int i = 0;\n    int sum = 0;\n\n    while (i &lt; 5) {\n        sum = sum + arr[i];\n        i = i + 1;\n    }\n\n    return sum;\n}\n\n// Function declaration with parameters\nint max(int a, int b) {\n    if (a &gt; b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n// Function with multiple parameters of different types\nfloat calculate(int x, float y, bool condition) {\n    float result = 0.0;\n\n    if (condition) {\n        result = x + y;\n    } else {\n        result = x - y;\n    }\n\n    return result;\n}\n\n// Recursive function to test function calls\nint factorial(int n) {\n    if (n &lt;= 1) {\n        return 1;\n    } else {\n        return n * factorial(n - 1);\n    }\n}\n\n// Main function with comprehensive language feature testing\nint main() {\n    // Local variable declarations\n    int a = 10;\n    int b = 20;\n    float f = 1.5;\n    bool flag = false;\n    char c = 'X';\n\n    // Local array declaration\n    int numbers[5];\n\n    // Initialize array using array access\n    numbers[0] = 10;\n    numbers[1] = 20;\n    numbers[2] = 30;\n    numbers[3] = 40;\n    numbers[4] = 50;\n\n    // Array access in expressions\n    int arraySum = numbers[0] + numbers[1];\n\n    // Array access with expressions as index\n    int index = 2;\n    int valueAtIndex = numbers[index];\n    int valueAtExpr = numbers[index + 1];\n\n    // Nested array access in expressions\n    int complexArrayExpr = numbers[numbers[0] / 10];\n\n    // Fill array using function\n    fillArray(numbers, 5);\n\n    // Sum array using function\n    int totalSum = sumArray(numbers);\n\n    // Basic arithmetic operators\n    int sum = a + b;\n    int diff = b - a;\n    int product = a * b;\n    int quotient = b / a;\n\n    // Complex arithmetic expression with nested parentheses\n    float complexExpr = (a + b) * (f / (b - a));\n\n    // Comparison operators\n    bool test1 = a &lt; b;\n    bool test2 = a &gt; b;\n    bool test3 = a &lt;= b;\n    bool test4 = a &gt;= b;\n\n    // Equality operators\n    bool equal = a == b;\n    bool notEqual = a != b;\n\n    // Logical operators with precedence testing\n    bool logicalExpr1 = a &lt; b &amp;&amp; f &gt; 1.0;\n    bool logicalExpr2 = a &gt; b || f &lt; 2.0;\n    bool logicalExpr3 = !(a == b) &amp;&amp; (f &gt;= 1.0 || b &lt;= 20);\n\n    // Assignment in expression\n    bool assignTest = (flag = true);\n\n    // Function calls\n    int maxValue = max(a, b);\n    float calcResult = calculate(a, f, flag);\n    int fact5 = factorial(5);\n\n    // Function call as part of expression\n    int exprWithCall = a + factorial(3);\n\n    // Nested function calls\n    int nestedCall = max(factorial(2), factorial(3));\n\n    // Array access in function call\n    int maxArrayValue = max(numbers[1], numbers[3]);\n\n    // If-else with array access in condition\n    if (numbers[0] &gt; numbers[1]) {\n        numbers[2] = numbers[0];\n    } else {\n        numbers[2] = numbers[1];\n    }\n\n    // While loop with array access\n    int j = 0;\n    while (j &lt; 5 &amp;&amp; numbers[j] &lt; 100) {\n        numbers[j] = numbers[j] * 2;\n        j = j + 1;\n    }\n\n    // Return statement with expression containing array access\n    return numbers[4] + factorial(numbers[0] / 10);\n}\n</code></pre>"},{"location":"2-syntaxAnalyzer/interface/","title":"Syntax Analyzer Interface","text":"<ul> <li>Input: BigC source code </li> <li>Output: Abstract Syntax Tree </li> </ul> <p>Source code repo: https://github.com/GoBigC/BigC/tree/main/pkg/syntax </p>"},{"location":"2-syntaxAnalyzer/sample-ast-tree/","title":"Abstract Syntax Tree","text":"<p>See all artifacts here. The most important output of the syntax analyzer is the AST, which we have visualized for this source file here. Note that the program's start symbol is not <code>AST Tree</code> but actually <code>Program</code>:</p> <pre><code>AST Tree:\n\u2514\u2500\u2500 Program (Line 4, Col 0) with 13 declarations\n    \u251c\u2500\u2500 VarDeclaration: globalInt of type int\n    \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 42\n    \u251c\u2500\u2500 VarDeclaration: globalFloat of type float\n    \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502   \u2502   \u2514\u2500\u2500 FloatLiteral: 3.141590\n    \u251c\u2500\u2500 VarDeclaration: globalBool of type bool\n    \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502   \u2502   \u2514\u2500\u2500 Identifier: true\n    \u251c\u2500\u2500 VarDeclaration: globalChar of type char\n    \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502   \u2502   \u2514\u2500\u2500 CharLiteral: 'A'\n    \u251c\u2500\u2500 VarDeclaration: globalInt2 of type int\n    \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502   \u2502   \u2514\u2500\u2500 UnaryExpression: '-'\n    \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 16\n    \u251c\u2500\u2500 VarDeclaration: globalFloat2 of type float\n    \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502   \u2502   \u2514\u2500\u2500 UnaryExpression: '-'\n    \u2502   \u2502       \u2514\u2500\u2500 FloatLiteral: 1.232100\n    \u251c\u2500\u2500 VarDeclaration: globalArray of type array of int with size 10\n    \u251c\u2500\u2500 Function: fillArray returns void with 2 parameters\n    \u2502   \u251c\u2500\u2500 Parameters:\n    \u2502   \u2502   \u251c\u2500\u2500 arr of type array of int with size 43\n    \u2502   \u2502   \u2514\u2500\u2500 value of type int\n    \u2502   \u2514\u2500\u2500 Body:\n    \u2502       \u2514\u2500\u2500 Block with 2 items\n    \u2502           \u251c\u2500\u2500 VarDeclaration: i of type int\n    \u2502           \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502           \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 0\n    \u2502           \u2514\u2500\u2500 WhileStatement\n    \u2502               \u251c\u2500\u2500 Condition:\n    \u2502               \u2502   \u2514\u2500\u2500 BinaryExpression: '&lt;'\n    \u2502               \u2502       \u251c\u2500\u2500 Left:\n    \u2502               \u2502       \u2502   \u251c\u2500\u2500 Identifier: i\n    \u2502               \u2502       \u2514\u2500\u2500 Right:\n    \u2502               \u2502           \u2514\u2500\u2500 IntegerLiteral: 5\n    \u2502               \u2514\u2500\u2500 Body:\n    \u2502                   \u2514\u2500\u2500 Block with 2 items\n    \u2502                       \u251c\u2500\u2500 ExpressionStatement\n    \u2502                       \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n    \u2502                       \u2502       \u251c\u2500\u2500 Left:\n    \u2502                       \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n    \u2502                       \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n    \u2502                       \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: arr\n    \u2502                       \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n    \u2502                       \u2502       \u2502   \u2502       \u2514\u2500\u2500 Identifier: i\n    \u2502                       \u2502       \u2514\u2500\u2500 Right:\n    \u2502                       \u2502           \u2514\u2500\u2500 Identifier: value\n    \u2502                       \u2514\u2500\u2500 ExpressionStatement\n    \u2502                           \u2514\u2500\u2500 BinaryExpression: '='\n    \u2502                               \u251c\u2500\u2500 Left:\n    \u2502                               \u2502   \u251c\u2500\u2500 Identifier: i\n    \u2502                               \u2514\u2500\u2500 Right:\n    \u2502                                   \u2514\u2500\u2500 BinaryExpression: '+'\n    \u2502                                       \u251c\u2500\u2500 Left:\n    \u2502                                       \u2502   \u251c\u2500\u2500 Identifier: i\n    \u2502                                       \u2514\u2500\u2500 Right:\n    \u2502                                           \u2514\u2500\u2500 IntegerLiteral: 1\n    \u251c\u2500\u2500 Function: sumArray returns int with 1 parameters\n    \u2502   \u251c\u2500\u2500 Parameters:\n    \u2502   \u2502   \u2514\u2500\u2500 arr of type array of int with size 5\n    \u2502   \u2514\u2500\u2500 Body:\n    \u2502       \u2514\u2500\u2500 Block with 4 items\n    \u2502           \u251c\u2500\u2500 VarDeclaration: i of type int\n    \u2502           \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502           \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 0\n    \u2502           \u251c\u2500\u2500 VarDeclaration: sum of type int\n    \u2502           \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502           \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 0\n    \u2502           \u251c\u2500\u2500 WhileStatement\n    \u2502           \u2502   \u251c\u2500\u2500 Condition:\n    \u2502           \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&lt;'\n    \u2502           \u2502   \u2502       \u251c\u2500\u2500 Left:\n    \u2502           \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: i\n    \u2502           \u2502   \u2502       \u2514\u2500\u2500 Right:\n    \u2502           \u2502   \u2502           \u2514\u2500\u2500 IntegerLiteral: 5\n    \u2502           \u2502   \u2514\u2500\u2500 Body:\n    \u2502           \u2502       \u2514\u2500\u2500 Block with 2 items\n    \u2502           \u2502           \u251c\u2500\u2500 ExpressionStatement\n    \u2502           \u2502           \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n    \u2502           \u2502           \u2502       \u251c\u2500\u2500 Left:\n    \u2502           \u2502           \u2502       \u2502   \u251c\u2500\u2500 Identifier: sum\n    \u2502           \u2502           \u2502       \u2514\u2500\u2500 Right:\n    \u2502           \u2502           \u2502           \u2514\u2500\u2500 BinaryExpression: '+'\n    \u2502           \u2502           \u2502               \u251c\u2500\u2500 Left:\n    \u2502           \u2502           \u2502               \u2502   \u251c\u2500\u2500 Identifier: sum\n    \u2502           \u2502           \u2502               \u2514\u2500\u2500 Right:\n    \u2502           \u2502           \u2502                   \u2514\u2500\u2500 ArrayAccess\n    \u2502           \u2502           \u2502                       \u251c\u2500\u2500 Array:\n    \u2502           \u2502           \u2502                       \u2502   \u251c\u2500\u2500 Identifier: arr\n    \u2502           \u2502           \u2502                       \u2514\u2500\u2500 Index:\n    \u2502           \u2502           \u2502                           \u2514\u2500\u2500 Identifier: i\n    \u2502           \u2502           \u2514\u2500\u2500 ExpressionStatement\n    \u2502           \u2502               \u2514\u2500\u2500 BinaryExpression: '='\n    \u2502           \u2502                   \u251c\u2500\u2500 Left:\n    \u2502           \u2502                   \u2502   \u251c\u2500\u2500 Identifier: i\n    \u2502           \u2502                   \u2514\u2500\u2500 Right:\n    \u2502           \u2502                       \u2514\u2500\u2500 BinaryExpression: '+'\n    \u2502           \u2502                           \u251c\u2500\u2500 Left:\n    \u2502           \u2502                           \u2502   \u251c\u2500\u2500 Identifier: i\n    \u2502           \u2502                           \u2514\u2500\u2500 Right:\n    \u2502           \u2502                               \u2514\u2500\u2500 IntegerLiteral: 1\n    \u2502           \u2514\u2500\u2500 ReturnStatement\n    \u2502               \u2514\u2500\u2500 Identifier: sum\n    \u251c\u2500\u2500 Function: max returns int with 2 parameters\n    \u2502   \u251c\u2500\u2500 Parameters:\n    \u2502   \u2502   \u251c\u2500\u2500 a of type int\n    \u2502   \u2502   \u2514\u2500\u2500 b of type int\n    \u2502   \u2514\u2500\u2500 Body:\n    \u2502       \u2514\u2500\u2500 Block with 1 items\n    \u2502           \u2514\u2500\u2500 IfStatement\n    \u2502               \u251c\u2500\u2500 Condition:\n    \u2502               \u2502   \u2514\u2500\u2500 BinaryExpression: '&gt;'\n    \u2502               \u2502       \u251c\u2500\u2500 Left:\n    \u2502               \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n    \u2502               \u2502       \u2514\u2500\u2500 Right:\n    \u2502               \u2502           \u2514\u2500\u2500 Identifier: b\n    \u2502               \u251c\u2500\u2500 ThenBlock:\n    \u2502               \u2502   \u251c\u2500\u2500 Block with 1 items\n    \u2502               \u2502   \u2502   \u2514\u2500\u2500 ReturnStatement\n    \u2502               \u2502   \u2502       \u2514\u2500\u2500 Identifier: a\n    \u2502               \u2514\u2500\u2500 ElseBlock:\n    \u2502                   \u2514\u2500\u2500 Block with 1 items\n    \u2502                       \u2514\u2500\u2500 ReturnStatement\n    \u2502                           \u2514\u2500\u2500 Identifier: b\n    \u251c\u2500\u2500 Function: calculate returns float with 3 parameters\n    \u2502   \u251c\u2500\u2500 Parameters:\n    \u2502   \u2502   \u251c\u2500\u2500 x of type int\n    \u2502   \u2502   \u251c\u2500\u2500 y of type float\n    \u2502   \u2502   \u2514\u2500\u2500 condition of type bool\n    \u2502   \u2514\u2500\u2500 Body:\n    \u2502       \u2514\u2500\u2500 Block with 3 items\n    \u2502           \u251c\u2500\u2500 VarDeclaration: result of type float\n    \u2502           \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502           \u2502   \u2502   \u2514\u2500\u2500 FloatLiteral: 0.000000\n    \u2502           \u251c\u2500\u2500 IfStatement\n    \u2502           \u2502   \u251c\u2500\u2500 Condition:\n    \u2502           \u2502   \u2502   \u2514\u2500\u2500 Identifier: condition\n    \u2502           \u2502   \u251c\u2500\u2500 ThenBlock:\n    \u2502           \u2502   \u2502   \u251c\u2500\u2500 Block with 1 items\n    \u2502           \u2502   \u2502   \u2502   \u2514\u2500\u2500 ExpressionStatement\n    \u2502           \u2502   \u2502   \u2502       \u2514\u2500\u2500 BinaryExpression: '='\n    \u2502           \u2502   \u2502   \u2502           \u251c\u2500\u2500 Left:\n    \u2502           \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 Identifier: result\n    \u2502           \u2502   \u2502   \u2502           \u2514\u2500\u2500 Right:\n    \u2502           \u2502   \u2502   \u2502               \u2514\u2500\u2500 BinaryExpression: '+'\n    \u2502           \u2502   \u2502   \u2502                   \u251c\u2500\u2500 Left:\n    \u2502           \u2502   \u2502   \u2502                   \u2502   \u251c\u2500\u2500 Identifier: x\n    \u2502           \u2502   \u2502   \u2502                   \u2514\u2500\u2500 Right:\n    \u2502           \u2502   \u2502   \u2502                       \u2514\u2500\u2500 Identifier: y\n    \u2502           \u2502   \u2514\u2500\u2500 ElseBlock:\n    \u2502           \u2502       \u2514\u2500\u2500 Block with 1 items\n    \u2502           \u2502           \u2514\u2500\u2500 ExpressionStatement\n    \u2502           \u2502               \u2514\u2500\u2500 BinaryExpression: '='\n    \u2502           \u2502                   \u251c\u2500\u2500 Left:\n    \u2502           \u2502                   \u2502   \u251c\u2500\u2500 Identifier: result\n    \u2502           \u2502                   \u2514\u2500\u2500 Right:\n    \u2502           \u2502                       \u2514\u2500\u2500 BinaryExpression: '-'\n    \u2502           \u2502                           \u251c\u2500\u2500 Left:\n    \u2502           \u2502                           \u2502   \u251c\u2500\u2500 Identifier: x\n    \u2502           \u2502                           \u2514\u2500\u2500 Right:\n    \u2502           \u2502                               \u2514\u2500\u2500 Identifier: y\n    \u2502           \u2514\u2500\u2500 ReturnStatement\n    \u2502               \u2514\u2500\u2500 Identifier: result\n    \u251c\u2500\u2500 Function: factorial returns int with 1 parameters\n    \u2502   \u251c\u2500\u2500 Parameters:\n    \u2502   \u2502   \u2514\u2500\u2500 n of type int\n    \u2502   \u2514\u2500\u2500 Body:\n    \u2502       \u2514\u2500\u2500 Block with 1 items\n    \u2502           \u2514\u2500\u2500 IfStatement\n    \u2502               \u251c\u2500\u2500 Condition:\n    \u2502               \u2502   \u2514\u2500\u2500 BinaryExpression: '&lt;='\n    \u2502               \u2502       \u251c\u2500\u2500 Left:\n    \u2502               \u2502       \u2502   \u251c\u2500\u2500 Identifier: n\n    \u2502               \u2502       \u2514\u2500\u2500 Right:\n    \u2502               \u2502           \u2514\u2500\u2500 IntegerLiteral: 1\n    \u2502               \u251c\u2500\u2500 ThenBlock:\n    \u2502               \u2502   \u251c\u2500\u2500 Block with 1 items\n    \u2502               \u2502   \u2502   \u2514\u2500\u2500 ReturnStatement\n    \u2502               \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 1\n    \u2502               \u2514\u2500\u2500 ElseBlock:\n    \u2502                   \u2514\u2500\u2500 Block with 1 items\n    \u2502                       \u2514\u2500\u2500 ReturnStatement\n    \u2502                           \u2514\u2500\u2500 BinaryExpression: '*'\n    \u2502                               \u251c\u2500\u2500 Left:\n    \u2502                               \u2502   \u251c\u2500\u2500 Identifier: n\n    \u2502                               \u2514\u2500\u2500 Right:\n    \u2502                                   \u2514\u2500\u2500 FunctionCall with 1 arguments\n    \u2502                                       \u251c\u2500\u2500 Function:\n    \u2502                                       \u2502   \u251c\u2500\u2500 Identifier: factorial\n    \u2502                                       \u2514\u2500\u2500 Arguments:\n    \u2502                                           \u2514\u2500\u2500 BinaryExpression: '-'\n    \u2502                                               \u251c\u2500\u2500 Left:\n    \u2502                                               \u2502   \u251c\u2500\u2500 Identifier: n\n    \u2502                                               \u2514\u2500\u2500 Right:\n    \u2502                                                   \u2514\u2500\u2500 IntegerLiteral: 1\n    \u2514\u2500\u2500 Function: main returns int with 0 parameters\n        \u2514\u2500\u2500 Body:\n            \u2514\u2500\u2500 Block with 43 items\n                \u251c\u2500\u2500 VarDeclaration: a of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 10\n                \u251c\u2500\u2500 VarDeclaration: b of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 20\n                \u251c\u2500\u2500 VarDeclaration: f of type float\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FloatLiteral: 1.500000\n                \u251c\u2500\u2500 VarDeclaration: flag of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 Identifier: false\n                \u251c\u2500\u2500 VarDeclaration: c of type char\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 CharLiteral: 'X'\n                \u251c\u2500\u2500 VarDeclaration: numbers of type array of int with size 5\n                \u251c\u2500\u2500 ExpressionStatement\n                \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502       \u251c\u2500\u2500 Left:\n                \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 0\n                \u2502       \u2514\u2500\u2500 Right:\n                \u2502           \u2514\u2500\u2500 IntegerLiteral: 10\n                \u251c\u2500\u2500 ExpressionStatement\n                \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502       \u251c\u2500\u2500 Left:\n                \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 1\n                \u2502       \u2514\u2500\u2500 Right:\n                \u2502           \u2514\u2500\u2500 IntegerLiteral: 20\n                \u251c\u2500\u2500 ExpressionStatement\n                \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502       \u251c\u2500\u2500 Left:\n                \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 2\n                \u2502       \u2514\u2500\u2500 Right:\n                \u2502           \u2514\u2500\u2500 IntegerLiteral: 30\n                \u251c\u2500\u2500 ExpressionStatement\n                \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502       \u251c\u2500\u2500 Left:\n                \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 3\n                \u2502       \u2514\u2500\u2500 Right:\n                \u2502           \u2514\u2500\u2500 IntegerLiteral: 40\n                \u251c\u2500\u2500 ExpressionStatement\n                \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502       \u251c\u2500\u2500 Left:\n                \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 4\n                \u2502       \u2514\u2500\u2500 Right:\n                \u2502           \u2514\u2500\u2500 IntegerLiteral: 50\n                \u251c\u2500\u2500 VarDeclaration: arraySum of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '+'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502   \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 0\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502               \u251c\u2500\u2500 Array:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502               \u2514\u2500\u2500 Index:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 1\n                \u251c\u2500\u2500 VarDeclaration: index of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 2\n                \u251c\u2500\u2500 VarDeclaration: valueAtIndex of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502       \u251c\u2500\u2500 Array:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502       \u2514\u2500\u2500 Index:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: index\n                \u251c\u2500\u2500 VarDeclaration: valueAtExpr of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502       \u251c\u2500\u2500 Array:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502       \u2514\u2500\u2500 Index:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '+'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: index\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 1\n                \u251c\u2500\u2500 VarDeclaration: complexArrayExpr of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502       \u251c\u2500\u2500 Array:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502       \u2514\u2500\u2500 Index:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '/'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502   \u2502               \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502   \u2502               \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502               \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502   \u2502               \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 0\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 10\n                \u251c\u2500\u2500 ExpressionStatement\n                \u2502   \u2514\u2500\u2500 FunctionCall with 2 arguments\n                \u2502       \u251c\u2500\u2500 Function:\n                \u2502       \u2502   \u251c\u2500\u2500 Identifier: fillArray\n                \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502           \u251c\u2500\u2500 Identifier: numbers\n                \u2502           \u2514\u2500\u2500 IntegerLiteral: 5\n                \u251c\u2500\u2500 VarDeclaration: totalSum of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FunctionCall with 1 arguments\n                \u2502   \u2502       \u251c\u2500\u2500 Function:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: sumArray\n                \u2502   \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: numbers\n                \u251c\u2500\u2500 VarDeclaration: sum of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '+'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: diff of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '-'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: b\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: a\n                \u251c\u2500\u2500 VarDeclaration: product of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '*'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: quotient of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '/'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: b\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: a\n                \u251c\u2500\u2500 VarDeclaration: complexExpr of type float\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '*'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 BinaryExpression: '+'\n                \u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 Right:\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 Identifier: b\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '/'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: f\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 BinaryExpression: '-'\n                \u2502   \u2502                       \u251c\u2500\u2500 Left:\n                \u2502   \u2502                       \u2502   \u251c\u2500\u2500 Identifier: b\n                \u2502   \u2502                       \u2514\u2500\u2500 Right:\n                \u2502   \u2502                           \u2514\u2500\u2500 Identifier: a\n                \u251c\u2500\u2500 VarDeclaration: test1 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&lt;'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: test2 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&gt;'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: test3 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&lt;='\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: test4 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&gt;='\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: equal of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '=='\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: notEqual of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '!='\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: logicalExpr1 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&amp;&amp;'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 BinaryExpression: '&lt;'\n                \u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 Right:\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 Identifier: b\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '&gt;'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: f\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 FloatLiteral: 1.000000\n                \u251c\u2500\u2500 VarDeclaration: logicalExpr2 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '||'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 BinaryExpression: '&gt;'\n                \u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 Right:\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 Identifier: b\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '&lt;'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: f\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 FloatLiteral: 2.000000\n                \u251c\u2500\u2500 VarDeclaration: logicalExpr3 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&amp;&amp;'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 UnaryExpression: '!'\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '=='\n                \u2502   \u2502       \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502       \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '||'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 BinaryExpression: '&gt;='\n                \u2502   \u2502               \u2502   \u2502   \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: f\n                \u2502   \u2502               \u2502   \u2502   \u2514\u2500\u2500 Right:\n                \u2502   \u2502               \u2502   \u2502       \u2514\u2500\u2500 FloatLiteral: 1.000000\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 BinaryExpression: '&lt;='\n                \u2502   \u2502                       \u251c\u2500\u2500 Left:\n                \u2502   \u2502                       \u2502   \u251c\u2500\u2500 Identifier: b\n                \u2502   \u2502                       \u2514\u2500\u2500 Right:\n                \u2502   \u2502                           \u2514\u2500\u2500 IntegerLiteral: 20\n                \u251c\u2500\u2500 VarDeclaration: assignTest of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: flag\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: true\n                \u251c\u2500\u2500 VarDeclaration: maxValue of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FunctionCall with 2 arguments\n                \u2502   \u2502       \u251c\u2500\u2500 Function:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: max\n                \u2502   \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: calcResult of type float\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FunctionCall with 3 arguments\n                \u2502   \u2502       \u251c\u2500\u2500 Function:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: calculate\n                \u2502   \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502           \u251c\u2500\u2500 Identifier: f\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: flag\n                \u251c\u2500\u2500 VarDeclaration: fact5 of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FunctionCall with 1 arguments\n                \u2502   \u2502       \u251c\u2500\u2500 Function:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: factorial\n                \u2502   \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u2514\u2500\u2500 IntegerLiteral: 5\n                \u251c\u2500\u2500 VarDeclaration: exprWithCall of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '+'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 FunctionCall with 1 arguments\n                \u2502   \u2502               \u251c\u2500\u2500 Function:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: factorial\n                \u2502   \u2502               \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 3\n                \u251c\u2500\u2500 VarDeclaration: nestedCall of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FunctionCall with 2 arguments\n                \u2502   \u2502       \u251c\u2500\u2500 Function:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: max\n                \u2502   \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u251c\u2500\u2500 FunctionCall with 1 arguments\n                \u2502   \u2502           \u2502   \u251c\u2500\u2500 Function:\n                \u2502   \u2502           \u2502   \u2502   \u251c\u2500\u2500 Identifier: factorial\n                \u2502   \u2502           \u2502   \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u2502       \u2514\u2500\u2500 IntegerLiteral: 2\n                \u2502   \u2502           \u2514\u2500\u2500 FunctionCall with 1 arguments\n                \u2502   \u2502               \u251c\u2500\u2500 Function:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: factorial\n                \u2502   \u2502               \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 3\n                \u251c\u2500\u2500 VarDeclaration: maxArrayValue of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FunctionCall with 2 arguments\n                \u2502   \u2502       \u251c\u2500\u2500 Function:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: max\n                \u2502   \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u251c\u2500\u2500 ArrayAccess\n                \u2502   \u2502           \u2502   \u251c\u2500\u2500 Array:\n                \u2502   \u2502           \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502           \u2502   \u2514\u2500\u2500 Index:\n                \u2502   \u2502           \u2502       \u2514\u2500\u2500 IntegerLiteral: 1\n                \u2502   \u2502           \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502               \u251c\u2500\u2500 Array:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502               \u2514\u2500\u2500 Index:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 3\n                \u251c\u2500\u2500 IfStatement\n                \u2502   \u251c\u2500\u2500 Condition:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&gt;'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502   \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 0\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502               \u251c\u2500\u2500 Array:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502               \u2514\u2500\u2500 Index:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 1\n                \u2502   \u251c\u2500\u2500 ThenBlock:\n                \u2502   \u2502   \u251c\u2500\u2500 Block with 1 items\n                \u2502   \u2502   \u2502   \u2514\u2500\u2500 ExpressionStatement\n                \u2502   \u2502   \u2502       \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502   \u2502   \u2502           \u251c\u2500\u2500 Left:\n                \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502   \u2502   \u2502           \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502   \u2502   \u2502           \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502   \u2502           \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502   \u2502   \u2502           \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 2\n                \u2502   \u2502   \u2502           \u2514\u2500\u2500 Right:\n                \u2502   \u2502   \u2502               \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502   \u2502                   \u251c\u2500\u2500 Array:\n                \u2502   \u2502   \u2502                   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502   \u2502                   \u2514\u2500\u2500 Index:\n                \u2502   \u2502   \u2502                       \u2514\u2500\u2500 IntegerLiteral: 0\n                \u2502   \u2514\u2500\u2500 ElseBlock:\n                \u2502       \u2514\u2500\u2500 Block with 1 items\n                \u2502           \u2514\u2500\u2500 ExpressionStatement\n                \u2502               \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502                   \u251c\u2500\u2500 Left:\n                \u2502                   \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502                   \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502                   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502                   \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502                   \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 2\n                \u2502                   \u2514\u2500\u2500 Right:\n                \u2502                       \u2514\u2500\u2500 ArrayAccess\n                \u2502                           \u251c\u2500\u2500 Array:\n                \u2502                           \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502                           \u2514\u2500\u2500 Index:\n                \u2502                               \u2514\u2500\u2500 IntegerLiteral: 1\n                \u251c\u2500\u2500 VarDeclaration: j of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 0\n                \u251c\u2500\u2500 WhileStatement\n                \u2502   \u251c\u2500\u2500 Condition:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&amp;&amp;'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 BinaryExpression: '&lt;'\n                \u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: j\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 Right:\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 5\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '&lt;'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502   \u2502               \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502   \u2502               \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502               \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502   \u2502               \u2502   \u2502       \u2514\u2500\u2500 Identifier: j\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 100\n                \u2502   \u2514\u2500\u2500 Body:\n                \u2502       \u2514\u2500\u2500 Block with 2 items\n                \u2502           \u251c\u2500\u2500 ExpressionStatement\n                \u2502           \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502           \u2502       \u251c\u2500\u2500 Left:\n                \u2502           \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502           \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502           \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502           \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502           \u2502       \u2502   \u2502       \u2514\u2500\u2500 Identifier: j\n                \u2502           \u2502       \u2514\u2500\u2500 Right:\n                \u2502           \u2502           \u2514\u2500\u2500 BinaryExpression: '*'\n                \u2502           \u2502               \u251c\u2500\u2500 Left:\n                \u2502           \u2502               \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502           \u2502               \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502           \u2502               \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502           \u2502               \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502           \u2502               \u2502   \u2502       \u2514\u2500\u2500 Identifier: j\n                \u2502           \u2502               \u2514\u2500\u2500 Right:\n                \u2502           \u2502                   \u2514\u2500\u2500 IntegerLiteral: 2\n                \u2502           \u2514\u2500\u2500 ExpressionStatement\n                \u2502               \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502                   \u251c\u2500\u2500 Left:\n                \u2502                   \u2502   \u251c\u2500\u2500 Identifier: j\n                \u2502                   \u2514\u2500\u2500 Right:\n                \u2502                       \u2514\u2500\u2500 BinaryExpression: '+'\n                \u2502                           \u251c\u2500\u2500 Left:\n                \u2502                           \u2502   \u251c\u2500\u2500 Identifier: j\n                \u2502                           \u2514\u2500\u2500 Right:\n                \u2502                               \u2514\u2500\u2500 IntegerLiteral: 1\n                \u2514\u2500\u2500 ReturnStatement\n                    \u2514\u2500\u2500 BinaryExpression: '+'\n                        \u251c\u2500\u2500 Left:\n                        \u2502   \u251c\u2500\u2500 ArrayAccess\n                        \u2502   \u2502   \u251c\u2500\u2500 Array:\n                        \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                        \u2502   \u2502   \u2514\u2500\u2500 Index:\n                        \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 4\n                        \u2514\u2500\u2500 Right:\n                            \u2514\u2500\u2500 FunctionCall with 1 arguments\n                                \u251c\u2500\u2500 Function:\n                                \u2502   \u251c\u2500\u2500 Identifier: factorial\n                                \u2514\u2500\u2500 Arguments:\n                                    \u2514\u2500\u2500 BinaryExpression: '/'\n                                        \u251c\u2500\u2500 Left:\n                                        \u2502   \u251c\u2500\u2500 ArrayAccess\n                                        \u2502   \u2502   \u251c\u2500\u2500 Array:\n                                        \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                                        \u2502   \u2502   \u2514\u2500\u2500 Index:\n                                        \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 0\n                                        \u2514\u2500\u2500 Right:\n                                            \u2514\u2500\u2500 IntegerLiteral: 10\n</code></pre>"},{"location":"2-syntaxAnalyzer/syntaxAnalyzerWritingNotes/","title":"Notes during Syntax Analyzer build","text":"<p>Copied from BigCooker parser README.md and AST README.md. </p>"},{"location":"2-syntaxAnalyzer/syntaxAnalyzerWritingNotes/#how-to-write-ast-node-structs-from-grammar-file","title":"How to write AST node structs from grammar file","text":"<ol> <li>Read the grammar (<code>BigC.g4</code>), determine which nodes are necessary to build the AST </li> <li>Not all symbols in the grammar file qualify to be an AST node (in which case we'd have a concrete syntax tree like <code>artifact/cst.txt</code>)</li> <li>AST node types include those that are important to the program struture: statement, expression, type, block, terminals, etc. </li> <li>AST node types do not include: operation precedence, delimiters like ';', precedence grouping symbols like '(' or ')'</li> </ol> <p>The ast.go file contains all the node types we considered necessary to build the AST</p> <ol> <li>Determine if the node should be a <code>struct</code> or an <code>interface</code></li> <li>A struct when: simple, concrete, no need for extending, need to hold data, need to be embedded into other structs </li> <li>An interface when: polymorphic, needs extending to subclasses/subinterfaces</li> </ol> <p>Specific example of when to use struct vs interface is explained as comments in <code>ast.go</code> </p> <ol> <li>Model the grammar </li> </ol> <p>Write the structs/interfaces so that it models the structure of the grammar, adding any fields to hold metadata if need be (for example, <code>Line</code> and <code>Column</code> number is considered metadata about the token).</p> <p>If you have ever written Entity class to wrap around a database in Java Spring, this is a parallel of that. The structs/interfaces in <code>ast.go</code> is a wrapper around the grammar so that we can populate its fields with data later. </p> <ol> <li>Rinse and repeat until covered all rules</li> </ol>"},{"location":"2-syntaxAnalyzer/syntaxAnalyzerWritingNotes/#how-to-build-ast-from-grammar-after-having-ast-nodes-defined","title":"How to build AST from grammar (after having AST nodes defined)","text":"<ol> <li>Locate the relevant items in grammar and <code>ast.go</code>. For example, this rule in the grammar</li> </ol> <pre><code>program\n    : declaration* EOF\n    ;\n</code></pre> <p>corresponds to this struct in <code>ast.go</code>:</p> <pre><code>type Program struct {\n    BaseNode\n    Declarations []Declaration\n}\n</code></pre> <p>and now we need to implement their corresponding visitor method in <code>parser.go</code>:</p> <pre><code>func (v *ASTBuilder) VisitProgram(ctx *ProgramContext)\n</code></pre> <ol> <li>Find the common tokens and populate the data in these fields first </li> </ol> <p>Consider this rule:  <pre><code>declaration\n    : type arrayNotation? Identifier declarationRemainder\n    ;\n</code></pre></p> <p>Which could have been a regular variable declaration or an array declaration. The first step is to process the common <code>type</code> token first, after this is done, consume the next token and decide if it is an array declaration. </p> <ol> <li>Branching </li> </ol> <p>When standing at a decision point (ie. after processing <code>type</code> and have to decide if this is an array declaration), proceed to process each case using if-else. </p> <p>This is when grammar unambiguity proves to be very useful: if the grammar is ambiguous, you would need to implement lookahead logic to lookahead several tokens to have enough information to keep going. </p> <p>Once again, this is very formulaic and requires detailed handling. </p>"},{"location":"2-syntaxAnalyzer/syntaxAnalyzerWritingNotes/#helpful-resources","title":"Helpful resources","text":"<ul> <li>This guy explains and demonstrates CST, AST, and happen to also explain interpreting vs. compiling pretty well in the process. He uses lex/yacc though, so if you're only familiar with Antlr it takes some extra effort to learn lex/yacc.</li> <li>Listener vs. Visitor explanation</li> </ul>"},{"location":"3-semanticAnalyzer/interface/","title":"Semantic Analysis Interface","text":"<ul> <li>Input: Abstract Syntax Tree </li> <li>Output: Annotated Abstract Syntax Tree (with typing &amp; scoping) </li> </ul> <p>Source code repo: https://github.com/GoBigC/BigC/tree/main/pkg/semantic </p>"},{"location":"4-codeGenerator/interface/","title":"Code Generator Interface","text":"<ul> <li>Input: Annotated Abstract Syntax Tree </li> <li>Output: Bare-metal RISC-V assembly</li> </ul> <p>Source code repo: https://github.com/GoBigC/BigC/tree/main/pkg/codegen </p> <p>We generate bare-metal RISC-V assembly, meaning it probably will not work on any OS. The resulting assembly code would be run on RARS the RISC-V assembler simulator. </p>"},{"location":"5-errorHandling/errorHandlingNotes/","title":"Error Handling Documentation","text":""},{"location":"5-errorHandling/errorHandlingNotes/#overview","title":"Overview","text":"<p>Our compiler's error handling consists of two main components:</p> <ol> <li>Syntax Error Handling: Enhances ANTLR's default syntax error messages with more helpful, Rust-style formatting</li> <li>Semantic Error Handling: Implements custom semantic analysis with detailed error reporting</li> </ol> <p>The compiler processes syntax first, then semantics. If any errors are detected at either stage, compilation stops.</p>"},{"location":"5-errorHandling/errorHandlingNotes/#syntax-error-handling","title":"Syntax Error Handling","text":""},{"location":"5-errorHandling/errorHandlingNotes/#how-it-works","title":"How It Works","text":"<p>The <code>NewSyntaxErrorHandler</code> intercepts ANTLR's syntax errors and reformats them to be more user-friendly. The handler:</p> <ol> <li>Captures the error location (line and column)</li> <li>Retrieves the source code line where the error occurred</li> <li>Categorizes the error type based on the error message</li> <li>Generates a formatted error message with visual indicators</li> </ol>"},{"location":"5-errorHandling/errorHandlingNotes/#example","title":"Example","text":"<p>For an input like:</p> <pre><code>int main() {\n  int x = 5\n  return x;\n}\n</code></pre> <p>Instead of a generic ANTLR message like:</p> <pre><code>line 3:2 missing ';' at 'return'\n</code></pre> <p>Our formatter produces:</p> <pre><code>line 2:10\n  int x = 5\n          ^\nSyntax Error: missing ';' at end of declaration\n</code></pre>"},{"location":"5-errorHandling/errorHandlingNotes/#error-categories","title":"Error Categories","text":"<p>The syntax error handler recognizes several common error patterns: 1. Missing braces and brackets 2. Missing semicolons 3. Invalid identifiers 4. Unexpected type keywords 5. Mismatched parentheses 6. Incomplete array declarations</p>"},{"location":"5-errorHandling/errorHandlingNotes/#semantic-error-handling","title":"Semantic Error Handling","text":""},{"location":"5-errorHandling/errorHandlingNotes/#how-it-works_1","title":"How It Works","text":"<p>Since ANTLR doesn't handle semantic analysis, we implement our own semantic analyzer that:</p> <ol> <li>Index out of bound</li> <li>Divide by zero</li> <li>Type mismatch:</li> <li>Assignment type mismatch</li> <li>Function return type mismatch</li> <li>Operator type mismatch</li> <li>Function argument type mismatch</li> <li>Invalid function</li> <li>Argument count mismatch</li> <li>Undefined symbol</li> <li>Variable out of scope</li> </ol> <p>The <code>NewSemanticErrorFormatter</code> then formats these errors in a consistent style.</p>"},{"location":"5-errorHandling/errorHandlingNotes/#example_1","title":"Example","text":"<p>For input like:</p> <pre><code>int main() {\n  int x = 10;\n  bool y = x + 5;\n  return y;\n}\n</code></pre> <p>Our semantic analyzer would produce:</p> <pre><code>line 3:12\n  bool y = x + 5;\n            ^\nSemantic Error: type mismatch: expected bool, got int\n</code></pre>"},{"location":"5-errorHandling/errorHandlingNotes/#error-detection-features","title":"Error Detection Features","text":"<p>The semantic error formatter includes specialized handling for: 1. Function argument count mismatches 2. Return type mismatches 3. Array access on non-array types 4. Undefined symbols 5. Type compatibility errors 6. Invalid operator usage</p>"},{"location":"5-errorHandling/errorHandlingNotes/#error-reporting-flow","title":"Error Reporting Flow","text":"<ol> <li>Source code is parsed by ANTLR with our custom <code>NewSyntaxErrorFormatter</code></li> <li>If syntax is valid, our semantic analyzer checks for semantic errors</li> <li>All errors are formatted in a consistent style and reported to the user</li> <li>Compilation stops if any errors are found at either stage</li> </ol> <p>Source code repo: https://github.com/GoBigC/BigC/tree/main/pkg/error_formatter </p>"}]}