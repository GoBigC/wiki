{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About BigC","text":"<p>BigC is a compiled programming language that's not as big as C.</p> <ul> <li> <p>Language design choices</p> <ul> <li>A compiled language</li> <li>Compiles to bare-metal RISC-V assembly</li> <li>Arguments are Pass-By-Value</li> <li>Compiler written in Go</li> </ul> </li> <li> <p>Tech stack</p> <ul> <li>ANTLR </li> <li>Go </li> <li>RISC-V assembly</li> </ul> </li> </ul>"},{"location":"contributing/","title":"Want to contribute to BigC?","text":"<p>It's all here, clone, fork, whatever you want! </p>"},{"location":"faq/","title":"FAQ","text":"<ol> <li> <p>Who are the authors?     </p> <ul> <li>@siddankthep (Sid) - Farmer #1 </li> <li>@lanphgphm (LP) - Farmer #2</li> <li>@brokisd (Khoa) - Farmer #3</li> </ul> </li> <li> <p>Why?    N/A</p> </li> <li> <p>Why the broccoli logo?  We were originally called \"TheBroccoliFarmers\", but had to change the organization's name due to practicality. </p> </li> <li> <p>Why BigC?   Because we think it's funny. </p> </li> <li> <p>Useful facts?   BigC compiles to bare-metal RISC-V assembly, which makes the language compliant with ZERO operating system. This choice was made out of practicality: we are too silly to support OS compliance </p> </li> </ol>"},{"location":"0-housekeeping/designChoices/","title":"BigC Is a Compiled Language","text":"<p>The choice to write a compiled language as opposed to an interpreted one is mostly because we wanted to write a compiler. </p> <p>As hardwares get more and more powerful, the previously slow execution time of a code snippet is hardly noticeable anymore. Languages that spawned recently are mostly compiled for this reason:</p> <p></p> <p>We think that we have significantly more chance to write interpreted languages in future work experiences, and we wanted to take this chance to know what it takes to write a compiled language. </p>"},{"location":"0-housekeeping/designChoices/#static-typing-static-scoping","title":"Static Typing &amp; Static Scoping","text":"<p>For safety and predictability, BigC requires explicit typing that will be checked during compilation. </p> <p>Dynamic scoping is generally not a good idea, though it makes things simpler for us language developers. Dynamically scoped languages like JavaScript or Bash are often used to write short scripts, and that is not the intended direction for BigC. </p>"},{"location":"0-housekeeping/designChoices/#targets-the-risc-v-isa","title":"Targets the RISC-V ISA","text":"<p>Compiling from a high-level language to another high-level language (like C or Java, or god forbid, Python) seems like cheating :) as if it is pseudo-compiling :) </p> <p>So to put ourselves to the challenge, we decided to compile our language to an assembly language. But to not make it too hard, we only write bare-metal assembly, which means bypassing the OS (like Linux), which means BigC does not cooperate with any operating system. </p> <p>So why RISC-V? </p> <p>It seems like a rising ISA and we want to know what's up :D It's also always a good use of time to learn assembly (right?)</p>"},{"location":"0-housekeeping/designChoices/#function-arguments-are-pass-by-value","title":"Function Arguments are Pass-By-Value","text":"<p>This choice was made out of practicality: Pass-By-Reference is hard :) and we believe that to do a good job at it, we need to know how to implement Pass-By-Value anyways. </p> <p>To get this project started, we were advised to only supports Pass-By-Value. </p>"},{"location":"0-housekeeping/designChoices/#compiler-written-in-go","title":"Compiler Written In Go","text":"<p>Because many companies are writing or even rewriting their tools in Go. Most recently Microsoft decided to write their TypeScript engine in Go (see here). </p> <p>And once again, we'd like to know why the language is so loved :)</p>"},{"location":"0-housekeeping/languageArchitecture/","title":"Language Architecture","text":"<p>graph TD     A[BigC Source File<code>source.via</code>] --&gt; B[Lexical Analyzer]     B --&gt;|Token stream| C[Syntax Analyzer]     C --&gt;|AST| D[Semantic Analyzer]     C --&gt; E[Error Handler]     D --&gt;|Symbol Table| F[Code Generator]     F --&gt;|Assembly<code>dest.asm</code>| G[\"RARS\"RISC-V Assembler &amp; Simulator]</p> <pre><code>subgraph Input Constructs\n    H[Built-in&lt;br&gt;Functions]\n    I[Branch]\n    J[Loop]\n    K[Expr]\n    L[Assign]\n    M[Block]\nend\n\nH --&gt; F\nI --&gt; F\nJ --&gt; F\nK --&gt; F\nL --&gt; F\nM --&gt; F\n</code></pre>"},{"location":"0-housekeeping/quirks/","title":"Language quirks","text":"<ol> <li>Array accessing    This is not supported:</li> </ol> <pre><code>// assuming arr is an array\narr[1+1];\n</code></pre> <p>You need to declare a separate variable to compute the index first:</p> <pre><code>// assuming arr is an array\nint k = 1+1;\narr[k];\n</code></pre>"},{"location":"0-housekeeping/techStack/","title":"Why ANTLR?","text":"<p>If not ANTLR, we would be working with lex/yacc (flex/bison), which would generate C codes, and it takes an extra step to make that compatible with Go code. The general advice we see is that if we don't have to use lex/yacc (ie. maintaining a legacy compiler that uses these), then we should look for different tools(source1), (source2).</p> <p> </p> <p>Go has its own version of yacc called goyacc. It is very close to yacc, but native to Go. And by translation, the previous warnings about using lex/yacc still kinda applies. </p> <p>ANTLR is more modern and supports Go. ANTLR also supports the Visitor pattern out of the box. For this and the fact that people warns so much against lex/yacc, we made the decision to use ANTLR as BigC's parser generator.</p> <p>Since ANTLR is a LL-parser, we should make our grammar not left-recursive. See more in the ANTLR lexer document</p>"},{"location":"0-housekeeping/techStack/#why-go","title":"Why Go?","text":"<p>Because we want to. </p> <p>Actually, because recently Microsoft port their entire Typescript engine into Go, which is such a big egoless move, and we thought Go must be really good for people at Microsoft to do this. We too would like to know why Go is rising so fast. </p>"},{"location":"0-housekeeping/techStack/#why-risc-v","title":"Why RISC-V?","text":"<p>Because we want to. </p>"},{"location":"0-housekeeping/vscodeLanguageSupport/","title":"bigsilly: Language Support for BigC in vscode","text":"<p>BigC source code file ends with <code>.uia</code> extension.</p> <p>There is a language support extension/plugin for vscode that provides basic syntax highlighting and comment toggle. </p> <p>Extension repo: https://github.com/GoBigC/bigsilly</p>"},{"location":"0-housekeeping/vscodeLanguageSupport/#how-to-install-the-extension","title":"How to install the extension","text":"<p>Follow the instructions in <code>README.md</code> of the above repository to install. </p> <p>There is no other way to install this extension, manual import is all we have. This is because to publish an extension on the market, one of us needs to sign up for Azure DevOps (and their never ending newsletter), and none of us are up to the task. </p>"},{"location":"1-grammar/bible/","title":"BigC Full Grammar","text":"<p>Note: The function declaration is there to support built-in functions (those starts with underscore '_')--like <code>_printInt()</code>, <code>_printFloat()</code>, etc. Custom function definition is not supported as of now.</p> <p>You can also read this at the grammar repository.</p>"},{"location":"1-grammar/bible/#parser-rules","title":"Parser Rules","text":"<p>program : declaration* EOF ;</p> <p>declaration : type Identifier arrayNotation? declarationRemainder ;</p> <p>arrayNotation : '[' expression ']' ;</p> <p>type : 'int' | 'float' | 'bool' | 'char' | 'void' ;</p> <p>declarationRemainder : '(' parameterList? ')' block | variableInitializer? ';' ;</p> <p>parameterList : parameter (',' parameter)* ;</p> <p>parameter : type Identifier arrayNotation? ;</p> <p>block : '{' blockItem* '}' ;</p> <p>blockItem : declaration | statement ;</p> <p>statement : ifStatement | nonIfStatement ;</p> <p>ifStatement : 'if' '(' expression ')' block elseClause? ;</p> <p>elseClause : 'else' (block | ifStatement) ;</p> <p>nonIfStatement : expression ';' | whileStatement | returnStatement ;</p> <p>whileStatement : 'while' '(' expression ')' block ;</p> <p>returnStatement : 'return' expression ';' ;</p> <p>// Expression precedence (from highest to lowest): // 1. Primary expressions (constants, variables, parenthesized) // 2. Postfix operations (arr[i], fn(), x++, x--) -- only support the first 2 // 3. Unary operations (-x, !x, ++x, --x) -- only support the first two // 4. Multiplicative (*, /) // 5. Additive (+, -) // 6. Comparison (&lt;, &lt;=, &gt;=, &gt;) // 7. Equality (==, !=) // 8. Logical AND (&amp;&amp;) // 9. Logical OR (||) // 10. Assignment (=)</p> <p>expression : assignmentExpression ;</p> <p>assignmentExpression : logicalOrExpression assignmentRest? ;</p> <p>assignmentRest : '=' assignmentExpression ;</p> <p>variableInitializer : '=' expression ;</p> <p>logicalOrExpression : logicalAndExpression logicalOrRest* ;</p> <p>logicalOrRest : '||' logicalAndExpression ;</p> <p>logicalAndExpression : equalityExpression logicalAndRest* ;</p> <p>logicalAndRest : '&amp;&amp;' equalityExpression ;</p> <p>equalityExpression : comparisonExpression equalityRest* ;</p> <p>equalityRest : equalityOperator comparisonExpression ;</p> <p>equalityOperator : '==' | '!=' ;</p> <p>comparisonExpression : additionExpression comparisonRest* ;</p> <p>comparisonRest : comparisonOperator additionExpression ;</p> <p>comparisonOperator : '&gt;' | '&lt;' | '&gt;=' | '&lt;=' ;</p> <p>additionExpression : multiplicationExpression additionExpressionRest* ;</p> <p>additionExpressionRest : addSubtractOperator multiplicationExpression ;</p> <p>addSubtractOperator : '+' | '-' ;</p> <p>multiplicationExpression : unaryExpression multiplicationExpressionRest* ;</p> <p>multiplicationExpressionRest : multDivModOperator unaryExpression ;</p> <p>multDivModOperator : '*' | '/' ;</p> <p>unaryExpression : postfixExpression | unaryOperator unaryExpression ;</p> <p>unaryOperator : '!' | '-' ;</p> <p>postfixExpression : primaryExpression (arrayAccess | functionCallArgs)? ;</p> <p>arrayAccess : '[' expression ']' ;</p> <p>functionCallArgs : '(' argList? ')' ;</p> <p>argList : assignmentExpression (',' assignmentExpression)* ;</p> <p>primaryExpression : Identifier | constant | '(' expression ')' ;</p> <p>constant : IntegerConstant | FloatingConstant | BooleanConstant | CharConstant ;</p>"},{"location":"1-grammar/bible/#lexer-rules","title":"Lexer Rules","text":"<p>BooleanConstant: 'true' | 'false'; CharConstant: '\\'' . '\\'';</p> <p>Identifier: [a-zA-Z_][a-zA-Z0-9_]*;</p> <p>IntegerConstant: [0-9]+; FloatingConstant: [0-9]+ '.' [0-9]+;</p> <p>WS: [ \\t\\r\\n]+ -&gt; skip; COMMENT: '//' ~[\\r\\n]* -&gt; skip; MULTILINE_COMMENT: '/*' .*? '*/' -&gt; skip;</p>"},{"location":"1-grammar/proof/","title":"Proof of Unambiguity","text":"<p>A grammar is considered unambiguous if it is LL(1) or LR(1), meaning the parser can determine the exact rule to apply next by examining only one token ahead in the input stream. In the same sense, the more tokens a parser needs to lookahead, the more ambiguous the grammar is. </p> <p>The proof of BigC's grammar unambiguity is therefore done by using ANTLR. ANTLR writes logs for each production rules it consume, and if the rule is unambiguous, it marks this rule to be <code>LL(1)? true</code>. When all rules/decisions in the grammar is marked like this, we say that the entire grammar is unambiguous. </p> <p>You can read the log here to verify that BigC has an unambiguous grammar: </p> <pre><code>DECISION 0 in rule program\n2025-04-07 16:01:03:482 LL1 LogManager.java:25 look=[{3..7}, &lt;EOF&gt;]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 1 in rule declaration\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[1, {8, 10, 18}]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 2 in rule declarationRemainder\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[{3..7}, 9]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 3 in rule declarationRemainder\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[18, 10]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 4 in rule declarationRemainder\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[8, {10, 18}]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 5 in rule parameterList\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[11, 9]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 6 in rule parameter\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[1, {9, 11}]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 7 in rule block\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[{3..8, 14, 16..17, 28, 31..36}, 13]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 8 in rule blockItem\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 look=[{3..7}, {8, 14, 16..17, 28, 31..36}]\n2025-04-07 16:01:03:483 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 9 in rule statement\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 look=[14, {8, 16..17, 28, 31..36}]\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 10 in rule ifStatement\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 look=[15, {3..8, 13..14, 16..17, 28, 31..36}]\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 11 in rule elseClause\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 look=[12, 14]\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 12 in rule nonIfStatement\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 look=[{8, 28, 31..36}, 16, 17]\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 13 in rule assignmentExpression\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 look=[18, {2, 9..11}]\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 14 in rule logicalOrExpression\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 look=[19, {2, 9..11, 18}]\n2025-04-07 16:01:03:484 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 15 in rule logicalAndExpression\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 look=[20, {2, 9..11, 18..19}]\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 16 in rule equalityExpression\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 look=[{21..22}, {2, 9..11, 18..20}]\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 17 in rule comparisonExpression\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 look=[{23..26}, {2, 9..11, 18..22}]\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 18 in rule additionExpression\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 look=[{27..28}, {2, 9..11, 18..26}]\n2025-04-07 16:01:03:485 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 19 in rule multiplicationExpression\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 look=[{29..30}, {2, 9..11, 18..28}]\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 20 in rule unaryExpression\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 look=[{8, 32..36}, {28, 31}]\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 21 in rule postfixExpression\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 look=[1, 8, {2, 9..11, 18..30}]\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 22 in rule functionCallArgs\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 look=[{8, 28, 31..36}, 9]\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 23 in rule argList\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 look=[11, 9]\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 LL(1)? true\n\nDECISION 24 in rule primaryExpression\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 look=[34, {32..33, 35..36}, 8]\n2025-04-07 16:01:03:486 LL1 LogManager.java:25 LL(1)? true\n</code></pre>"},{"location":"1-grammar/sample/","title":"Sample BigC Code","text":"<p>See benchmark test. This example may not be comprehensive.</p> <pre><code>int x = 15;\nfloat y = 5.5;\n\nint main() {\n    // ================INT====================\n    int addInt = 1 + 2050;\n    _printInt(addInt); // Expected: 2051\n\n    int subInt = 5 - 2;\n    _printInt(subInt); // Expected: 3\n\n    int mulInt = 3 * 4;\n    _printInt(mulInt); // Expected: 12\n\n    int divInt = 8 / 2;\n    _printInt(divInt); // Expected: 4\n\n    int literalInt = 4;\n    _printInt(literalInt); // Expected: 4\n\n    int minusInt = -5;\n    _printInt(minusInt); // Expected: -5\n\n    int mixedAddInt = x + 12;\n    _printInt(mixedAddInt); // Expected: 22\n\n    int mixMulInt = x * 1;\n    _printInt(mixMulInt); // Expected: 10\n\n    int mixSubInt = x -1;\n    _printInt(mixSubInt);  // Expected: 9\n\n    int mixDivInt = x/2;\n    _printInt(mixDivInt);  // Expected: 5\n\n    _printInt(13); // Expected: 13\n\n    // =================FLOAT===================\n    float addFloat = 3.14 + 2.5;\n    _printFloat(addFloat); // Expected: 5.64\n\n    float subFloat = 10.5 - 4.2;\n    _printFloat(subFloat); // Expected: 6.3\n\n    float mulFloat = 2.0 * 3.5;\n    _printFloat(mulFloat); // Expected: 7.0\n\n    float divFloat = 15.0 / 3.0;\n    _printFloat(divFloat); // Expected: 5.0\n\n    float literalFloat = 6.28;\n    _printFloat(literalFloat); // Expected: 6.28\n\n    float minusFloat = -3.14;\n    _printFloat(minusFloat); // Expected: -3.14\n\n    float mixedAddFloat = y + 2.3;\n    _printFloat(mixedAddFloat); // Expected: 7.8\n\n    float mixMulFloat = y * 2.0;\n    _printFloat(mixMulFloat); // Expected: 11.0\n\n    float mixSubFloat = y - 1.1;\n    _printFloat(mixSubFloat); // Expected: 4.4\n\n    float mixDivFloat = y / 2.2;\n    _printFloat(mixDivFloat); // Expected: 2.5\n\n    _printFloat(3.14159); // Expected: 3.14159\n\n    // =================CHAR===================\n    char literalChar = 'A';\n    _printChar(literalChar);\n\n    _printChar('B');\n\n    // =================BOOL===================\n    bool trueValue = true;\n    _printBool(trueValue); // Expected: 1\n\n    bool falseValue = false;\n    _printBool(falseValue); // Expected: 0\n\n    bool andOperation = true &amp;&amp; false;\n    _printBool(andOperation); // Expected: 0\n\n    bool orOperation = true || false;\n    _printBool(orOperation); // Expected: 1\n\n    bool notOperation = !trueValue;\n    _printBool(notOperation); // Expected: 0\n\n    bool comparisonLT = (5 &lt; 10);\n    _printBool(comparisonLT); // Expected: 1\n\n    bool comparisonGT = (20 &gt; 15);\n    _printBool(comparisonGT); // Expected: 1\n\n    bool comparisonEQ = (7 == 7);\n    _printBool(comparisonEQ); // Expected: 1\n\n    bool comparisonNEQ = (8 != 9);\n    _printBool(comparisonNEQ); // Expected: 1\n\n    // ================ARRAY====================\n    int a[x];\n    a[0] = 69;\n    _printInt(a[0]);\n\n    // this is not going to work --&gt; workaround at (I)\n    // int z = 4;\n    // a[x-z] = 420; // 42.0 thi sao?\n    // int n = a[x-z];\n    // _printInt(n);\n\n    // (I)\n    int z = 4;\n    int k = x-z;\n    a[k] = 420;\n    int n = a[k];\n    _printInt(n);\n\n    // (I)\n    a[k] = 425;\n    _printInt(a[k]);\n    n = a[k];\n    _printInt(n);\n\n    int n1;\n    n1 = a[k];\n    _printInt(n1);\n\n    a[0] = 1;\n    _printInt(a[0]);\n    a[1] = 1;\n    // a[2] = 1.2; // should error\n    // int d[0]; // should error\n\n    int ff = a[0] + a[1];\n    _printInt(n);\n\n    int b[x+1];\n    float c[x+z+1];\n    c[0] = 3.1412;\n    c[1] = 6.699;\n    _printFloat(c[1]);\n    _printFloat(c[0]);\n\n    float prices[3];\n    prices[0] = 10.5;\n    prices[1] = 20.75;\n    prices[2] = 15.25;\n\n    _printFloat(prices[0]);  // expect: 10.5\n    _printFloat(prices[1]);  // expext: 20.75\n\n    float total = prices[0] + prices[1] + prices[2];\n    _printFloat(total);  // expect: 46.5\n\n    return 0;\n}\n</code></pre>"},{"location":"2-syntaxAnalyzer/interface/","title":"Syntax Analyzer Interface","text":"<ul> <li>Input: BigC source code </li> <li>Output: Abstract Syntax Tree </li> </ul> <p>Source code repo: https://github.com/GoBigC/BigC/tree/main/pkg/syntax </p>"},{"location":"2-syntaxAnalyzer/sampleAST/","title":"Abstract Syntax Tree","text":"<p>See all artifacts here. The most important output of the syntax analyzer is the AST, which we have visualized for this source file here. Note that the program's start symbol is not <code>AST Tree</code> but actually <code>Program</code>:</p> <pre><code>AST Tree:\n\u2514\u2500\u2500 Program (Line 4, Col 0) with 13 declarations\n    \u251c\u2500\u2500 VarDeclaration: globalInt of type int\n    \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 42\n    \u251c\u2500\u2500 VarDeclaration: globalFloat of type float\n    \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502   \u2502   \u2514\u2500\u2500 FloatLiteral: 3.141590\n    \u251c\u2500\u2500 VarDeclaration: globalBool of type bool\n    \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502   \u2502   \u2514\u2500\u2500 Identifier: true\n    \u251c\u2500\u2500 VarDeclaration: globalChar of type char\n    \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502   \u2502   \u2514\u2500\u2500 CharLiteral: 'A'\n    \u251c\u2500\u2500 VarDeclaration: globalInt2 of type int\n    \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502   \u2502   \u2514\u2500\u2500 UnaryExpression: '-'\n    \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 16\n    \u251c\u2500\u2500 VarDeclaration: globalFloat2 of type float\n    \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502   \u2502   \u2514\u2500\u2500 UnaryExpression: '-'\n    \u2502   \u2502       \u2514\u2500\u2500 FloatLiteral: 1.232100\n    \u251c\u2500\u2500 VarDeclaration: globalArray of type array of int with size 10\n    \u251c\u2500\u2500 Function: fillArray returns void with 2 parameters\n    \u2502   \u251c\u2500\u2500 Parameters:\n    \u2502   \u2502   \u251c\u2500\u2500 arr of type array of int with size 43\n    \u2502   \u2502   \u2514\u2500\u2500 value of type int\n    \u2502   \u2514\u2500\u2500 Body:\n    \u2502       \u2514\u2500\u2500 Block with 2 items\n    \u2502           \u251c\u2500\u2500 VarDeclaration: i of type int\n    \u2502           \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502           \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 0\n    \u2502           \u2514\u2500\u2500 WhileStatement\n    \u2502               \u251c\u2500\u2500 Condition:\n    \u2502               \u2502   \u2514\u2500\u2500 BinaryExpression: '&lt;'\n    \u2502               \u2502       \u251c\u2500\u2500 Left:\n    \u2502               \u2502       \u2502   \u251c\u2500\u2500 Identifier: i\n    \u2502               \u2502       \u2514\u2500\u2500 Right:\n    \u2502               \u2502           \u2514\u2500\u2500 IntegerLiteral: 5\n    \u2502               \u2514\u2500\u2500 Body:\n    \u2502                   \u2514\u2500\u2500 Block with 2 items\n    \u2502                       \u251c\u2500\u2500 ExpressionStatement\n    \u2502                       \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n    \u2502                       \u2502       \u251c\u2500\u2500 Left:\n    \u2502                       \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n    \u2502                       \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n    \u2502                       \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: arr\n    \u2502                       \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n    \u2502                       \u2502       \u2502   \u2502       \u2514\u2500\u2500 Identifier: i\n    \u2502                       \u2502       \u2514\u2500\u2500 Right:\n    \u2502                       \u2502           \u2514\u2500\u2500 Identifier: value\n    \u2502                       \u2514\u2500\u2500 ExpressionStatement\n    \u2502                           \u2514\u2500\u2500 BinaryExpression: '='\n    \u2502                               \u251c\u2500\u2500 Left:\n    \u2502                               \u2502   \u251c\u2500\u2500 Identifier: i\n    \u2502                               \u2514\u2500\u2500 Right:\n    \u2502                                   \u2514\u2500\u2500 BinaryExpression: '+'\n    \u2502                                       \u251c\u2500\u2500 Left:\n    \u2502                                       \u2502   \u251c\u2500\u2500 Identifier: i\n    \u2502                                       \u2514\u2500\u2500 Right:\n    \u2502                                           \u2514\u2500\u2500 IntegerLiteral: 1\n    \u251c\u2500\u2500 Function: sumArray returns int with 1 parameters\n    \u2502   \u251c\u2500\u2500 Parameters:\n    \u2502   \u2502   \u2514\u2500\u2500 arr of type array of int with size 5\n    \u2502   \u2514\u2500\u2500 Body:\n    \u2502       \u2514\u2500\u2500 Block with 4 items\n    \u2502           \u251c\u2500\u2500 VarDeclaration: i of type int\n    \u2502           \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502           \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 0\n    \u2502           \u251c\u2500\u2500 VarDeclaration: sum of type int\n    \u2502           \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502           \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 0\n    \u2502           \u251c\u2500\u2500 WhileStatement\n    \u2502           \u2502   \u251c\u2500\u2500 Condition:\n    \u2502           \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&lt;'\n    \u2502           \u2502   \u2502       \u251c\u2500\u2500 Left:\n    \u2502           \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: i\n    \u2502           \u2502   \u2502       \u2514\u2500\u2500 Right:\n    \u2502           \u2502   \u2502           \u2514\u2500\u2500 IntegerLiteral: 5\n    \u2502           \u2502   \u2514\u2500\u2500 Body:\n    \u2502           \u2502       \u2514\u2500\u2500 Block with 2 items\n    \u2502           \u2502           \u251c\u2500\u2500 ExpressionStatement\n    \u2502           \u2502           \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n    \u2502           \u2502           \u2502       \u251c\u2500\u2500 Left:\n    \u2502           \u2502           \u2502       \u2502   \u251c\u2500\u2500 Identifier: sum\n    \u2502           \u2502           \u2502       \u2514\u2500\u2500 Right:\n    \u2502           \u2502           \u2502           \u2514\u2500\u2500 BinaryExpression: '+'\n    \u2502           \u2502           \u2502               \u251c\u2500\u2500 Left:\n    \u2502           \u2502           \u2502               \u2502   \u251c\u2500\u2500 Identifier: sum\n    \u2502           \u2502           \u2502               \u2514\u2500\u2500 Right:\n    \u2502           \u2502           \u2502                   \u2514\u2500\u2500 ArrayAccess\n    \u2502           \u2502           \u2502                       \u251c\u2500\u2500 Array:\n    \u2502           \u2502           \u2502                       \u2502   \u251c\u2500\u2500 Identifier: arr\n    \u2502           \u2502           \u2502                       \u2514\u2500\u2500 Index:\n    \u2502           \u2502           \u2502                           \u2514\u2500\u2500 Identifier: i\n    \u2502           \u2502           \u2514\u2500\u2500 ExpressionStatement\n    \u2502           \u2502               \u2514\u2500\u2500 BinaryExpression: '='\n    \u2502           \u2502                   \u251c\u2500\u2500 Left:\n    \u2502           \u2502                   \u2502   \u251c\u2500\u2500 Identifier: i\n    \u2502           \u2502                   \u2514\u2500\u2500 Right:\n    \u2502           \u2502                       \u2514\u2500\u2500 BinaryExpression: '+'\n    \u2502           \u2502                           \u251c\u2500\u2500 Left:\n    \u2502           \u2502                           \u2502   \u251c\u2500\u2500 Identifier: i\n    \u2502           \u2502                           \u2514\u2500\u2500 Right:\n    \u2502           \u2502                               \u2514\u2500\u2500 IntegerLiteral: 1\n    \u2502           \u2514\u2500\u2500 ReturnStatement\n    \u2502               \u2514\u2500\u2500 Identifier: sum\n    \u251c\u2500\u2500 Function: max returns int with 2 parameters\n    \u2502   \u251c\u2500\u2500 Parameters:\n    \u2502   \u2502   \u251c\u2500\u2500 a of type int\n    \u2502   \u2502   \u2514\u2500\u2500 b of type int\n    \u2502   \u2514\u2500\u2500 Body:\n    \u2502       \u2514\u2500\u2500 Block with 1 items\n    \u2502           \u2514\u2500\u2500 IfStatement\n    \u2502               \u251c\u2500\u2500 Condition:\n    \u2502               \u2502   \u2514\u2500\u2500 BinaryExpression: '&gt;'\n    \u2502               \u2502       \u251c\u2500\u2500 Left:\n    \u2502               \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n    \u2502               \u2502       \u2514\u2500\u2500 Right:\n    \u2502               \u2502           \u2514\u2500\u2500 Identifier: b\n    \u2502               \u251c\u2500\u2500 ThenBlock:\n    \u2502               \u2502   \u251c\u2500\u2500 Block with 1 items\n    \u2502               \u2502   \u2502   \u2514\u2500\u2500 ReturnStatement\n    \u2502               \u2502   \u2502       \u2514\u2500\u2500 Identifier: a\n    \u2502               \u2514\u2500\u2500 ElseBlock:\n    \u2502                   \u2514\u2500\u2500 Block with 1 items\n    \u2502                       \u2514\u2500\u2500 ReturnStatement\n    \u2502                           \u2514\u2500\u2500 Identifier: b\n    \u251c\u2500\u2500 Function: calculate returns float with 3 parameters\n    \u2502   \u251c\u2500\u2500 Parameters:\n    \u2502   \u2502   \u251c\u2500\u2500 x of type int\n    \u2502   \u2502   \u251c\u2500\u2500 y of type float\n    \u2502   \u2502   \u2514\u2500\u2500 condition of type bool\n    \u2502   \u2514\u2500\u2500 Body:\n    \u2502       \u2514\u2500\u2500 Block with 3 items\n    \u2502           \u251c\u2500\u2500 VarDeclaration: result of type float\n    \u2502           \u2502   \u251c\u2500\u2500 Initializer:\n    \u2502           \u2502   \u2502   \u2514\u2500\u2500 FloatLiteral: 0.000000\n    \u2502           \u251c\u2500\u2500 IfStatement\n    \u2502           \u2502   \u251c\u2500\u2500 Condition:\n    \u2502           \u2502   \u2502   \u2514\u2500\u2500 Identifier: condition\n    \u2502           \u2502   \u251c\u2500\u2500 ThenBlock:\n    \u2502           \u2502   \u2502   \u251c\u2500\u2500 Block with 1 items\n    \u2502           \u2502   \u2502   \u2502   \u2514\u2500\u2500 ExpressionStatement\n    \u2502           \u2502   \u2502   \u2502       \u2514\u2500\u2500 BinaryExpression: '='\n    \u2502           \u2502   \u2502   \u2502           \u251c\u2500\u2500 Left:\n    \u2502           \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 Identifier: result\n    \u2502           \u2502   \u2502   \u2502           \u2514\u2500\u2500 Right:\n    \u2502           \u2502   \u2502   \u2502               \u2514\u2500\u2500 BinaryExpression: '+'\n    \u2502           \u2502   \u2502   \u2502                   \u251c\u2500\u2500 Left:\n    \u2502           \u2502   \u2502   \u2502                   \u2502   \u251c\u2500\u2500 Identifier: x\n    \u2502           \u2502   \u2502   \u2502                   \u2514\u2500\u2500 Right:\n    \u2502           \u2502   \u2502   \u2502                       \u2514\u2500\u2500 Identifier: y\n    \u2502           \u2502   \u2514\u2500\u2500 ElseBlock:\n    \u2502           \u2502       \u2514\u2500\u2500 Block with 1 items\n    \u2502           \u2502           \u2514\u2500\u2500 ExpressionStatement\n    \u2502           \u2502               \u2514\u2500\u2500 BinaryExpression: '='\n    \u2502           \u2502                   \u251c\u2500\u2500 Left:\n    \u2502           \u2502                   \u2502   \u251c\u2500\u2500 Identifier: result\n    \u2502           \u2502                   \u2514\u2500\u2500 Right:\n    \u2502           \u2502                       \u2514\u2500\u2500 BinaryExpression: '-'\n    \u2502           \u2502                           \u251c\u2500\u2500 Left:\n    \u2502           \u2502                           \u2502   \u251c\u2500\u2500 Identifier: x\n    \u2502           \u2502                           \u2514\u2500\u2500 Right:\n    \u2502           \u2502                               \u2514\u2500\u2500 Identifier: y\n    \u2502           \u2514\u2500\u2500 ReturnStatement\n    \u2502               \u2514\u2500\u2500 Identifier: result\n    \u251c\u2500\u2500 Function: factorial returns int with 1 parameters\n    \u2502   \u251c\u2500\u2500 Parameters:\n    \u2502   \u2502   \u2514\u2500\u2500 n of type int\n    \u2502   \u2514\u2500\u2500 Body:\n    \u2502       \u2514\u2500\u2500 Block with 1 items\n    \u2502           \u2514\u2500\u2500 IfStatement\n    \u2502               \u251c\u2500\u2500 Condition:\n    \u2502               \u2502   \u2514\u2500\u2500 BinaryExpression: '&lt;='\n    \u2502               \u2502       \u251c\u2500\u2500 Left:\n    \u2502               \u2502       \u2502   \u251c\u2500\u2500 Identifier: n\n    \u2502               \u2502       \u2514\u2500\u2500 Right:\n    \u2502               \u2502           \u2514\u2500\u2500 IntegerLiteral: 1\n    \u2502               \u251c\u2500\u2500 ThenBlock:\n    \u2502               \u2502   \u251c\u2500\u2500 Block with 1 items\n    \u2502               \u2502   \u2502   \u2514\u2500\u2500 ReturnStatement\n    \u2502               \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 1\n    \u2502               \u2514\u2500\u2500 ElseBlock:\n    \u2502                   \u2514\u2500\u2500 Block with 1 items\n    \u2502                       \u2514\u2500\u2500 ReturnStatement\n    \u2502                           \u2514\u2500\u2500 BinaryExpression: '*'\n    \u2502                               \u251c\u2500\u2500 Left:\n    \u2502                               \u2502   \u251c\u2500\u2500 Identifier: n\n    \u2502                               \u2514\u2500\u2500 Right:\n    \u2502                                   \u2514\u2500\u2500 FunctionCall with 1 arguments\n    \u2502                                       \u251c\u2500\u2500 Function:\n    \u2502                                       \u2502   \u251c\u2500\u2500 Identifier: factorial\n    \u2502                                       \u2514\u2500\u2500 Arguments:\n    \u2502                                           \u2514\u2500\u2500 BinaryExpression: '-'\n    \u2502                                               \u251c\u2500\u2500 Left:\n    \u2502                                               \u2502   \u251c\u2500\u2500 Identifier: n\n    \u2502                                               \u2514\u2500\u2500 Right:\n    \u2502                                                   \u2514\u2500\u2500 IntegerLiteral: 1\n    \u2514\u2500\u2500 Function: main returns int with 0 parameters\n        \u2514\u2500\u2500 Body:\n            \u2514\u2500\u2500 Block with 43 items\n                \u251c\u2500\u2500 VarDeclaration: a of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 10\n                \u251c\u2500\u2500 VarDeclaration: b of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 20\n                \u251c\u2500\u2500 VarDeclaration: f of type float\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FloatLiteral: 1.500000\n                \u251c\u2500\u2500 VarDeclaration: flag of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 Identifier: false\n                \u251c\u2500\u2500 VarDeclaration: c of type char\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 CharLiteral: 'X'\n                \u251c\u2500\u2500 VarDeclaration: numbers of type array of int with size 5\n                \u251c\u2500\u2500 ExpressionStatement\n                \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502       \u251c\u2500\u2500 Left:\n                \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 0\n                \u2502       \u2514\u2500\u2500 Right:\n                \u2502           \u2514\u2500\u2500 IntegerLiteral: 10\n                \u251c\u2500\u2500 ExpressionStatement\n                \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502       \u251c\u2500\u2500 Left:\n                \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 1\n                \u2502       \u2514\u2500\u2500 Right:\n                \u2502           \u2514\u2500\u2500 IntegerLiteral: 20\n                \u251c\u2500\u2500 ExpressionStatement\n                \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502       \u251c\u2500\u2500 Left:\n                \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 2\n                \u2502       \u2514\u2500\u2500 Right:\n                \u2502           \u2514\u2500\u2500 IntegerLiteral: 30\n                \u251c\u2500\u2500 ExpressionStatement\n                \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502       \u251c\u2500\u2500 Left:\n                \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 3\n                \u2502       \u2514\u2500\u2500 Right:\n                \u2502           \u2514\u2500\u2500 IntegerLiteral: 40\n                \u251c\u2500\u2500 ExpressionStatement\n                \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502       \u251c\u2500\u2500 Left:\n                \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 4\n                \u2502       \u2514\u2500\u2500 Right:\n                \u2502           \u2514\u2500\u2500 IntegerLiteral: 50\n                \u251c\u2500\u2500 VarDeclaration: arraySum of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '+'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502   \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 0\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502               \u251c\u2500\u2500 Array:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502               \u2514\u2500\u2500 Index:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 1\n                \u251c\u2500\u2500 VarDeclaration: index of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 2\n                \u251c\u2500\u2500 VarDeclaration: valueAtIndex of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502       \u251c\u2500\u2500 Array:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502       \u2514\u2500\u2500 Index:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: index\n                \u251c\u2500\u2500 VarDeclaration: valueAtExpr of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502       \u251c\u2500\u2500 Array:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502       \u2514\u2500\u2500 Index:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '+'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: index\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 1\n                \u251c\u2500\u2500 VarDeclaration: complexArrayExpr of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502       \u251c\u2500\u2500 Array:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502       \u2514\u2500\u2500 Index:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '/'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502   \u2502               \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502   \u2502               \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502               \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502   \u2502               \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 0\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 10\n                \u251c\u2500\u2500 ExpressionStatement\n                \u2502   \u2514\u2500\u2500 FunctionCall with 2 arguments\n                \u2502       \u251c\u2500\u2500 Function:\n                \u2502       \u2502   \u251c\u2500\u2500 Identifier: fillArray\n                \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502           \u251c\u2500\u2500 Identifier: numbers\n                \u2502           \u2514\u2500\u2500 IntegerLiteral: 5\n                \u251c\u2500\u2500 VarDeclaration: totalSum of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FunctionCall with 1 arguments\n                \u2502   \u2502       \u251c\u2500\u2500 Function:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: sumArray\n                \u2502   \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: numbers\n                \u251c\u2500\u2500 VarDeclaration: sum of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '+'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: diff of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '-'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: b\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: a\n                \u251c\u2500\u2500 VarDeclaration: product of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '*'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: quotient of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '/'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: b\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: a\n                \u251c\u2500\u2500 VarDeclaration: complexExpr of type float\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '*'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 BinaryExpression: '+'\n                \u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 Right:\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 Identifier: b\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '/'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: f\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 BinaryExpression: '-'\n                \u2502   \u2502                       \u251c\u2500\u2500 Left:\n                \u2502   \u2502                       \u2502   \u251c\u2500\u2500 Identifier: b\n                \u2502   \u2502                       \u2514\u2500\u2500 Right:\n                \u2502   \u2502                           \u2514\u2500\u2500 Identifier: a\n                \u251c\u2500\u2500 VarDeclaration: test1 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&lt;'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: test2 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&gt;'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: test3 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&lt;='\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: test4 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&gt;='\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: equal of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '=='\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: notEqual of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '!='\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: logicalExpr1 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&amp;&amp;'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 BinaryExpression: '&lt;'\n                \u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 Right:\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 Identifier: b\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '&gt;'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: f\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 FloatLiteral: 1.000000\n                \u251c\u2500\u2500 VarDeclaration: logicalExpr2 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '||'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 BinaryExpression: '&gt;'\n                \u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 Right:\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 Identifier: b\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '&lt;'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: f\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 FloatLiteral: 2.000000\n                \u251c\u2500\u2500 VarDeclaration: logicalExpr3 of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&amp;&amp;'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 UnaryExpression: '!'\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '=='\n                \u2502   \u2502       \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502       \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '||'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 BinaryExpression: '&gt;='\n                \u2502   \u2502               \u2502   \u2502   \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: f\n                \u2502   \u2502               \u2502   \u2502   \u2514\u2500\u2500 Right:\n                \u2502   \u2502               \u2502   \u2502       \u2514\u2500\u2500 FloatLiteral: 1.000000\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 BinaryExpression: '&lt;='\n                \u2502   \u2502                       \u251c\u2500\u2500 Left:\n                \u2502   \u2502                       \u2502   \u251c\u2500\u2500 Identifier: b\n                \u2502   \u2502                       \u2514\u2500\u2500 Right:\n                \u2502   \u2502                           \u2514\u2500\u2500 IntegerLiteral: 20\n                \u251c\u2500\u2500 VarDeclaration: assignTest of type bool\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: flag\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: true\n                \u251c\u2500\u2500 VarDeclaration: maxValue of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FunctionCall with 2 arguments\n                \u2502   \u2502       \u251c\u2500\u2500 Function:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: max\n                \u2502   \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: b\n                \u251c\u2500\u2500 VarDeclaration: calcResult of type float\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FunctionCall with 3 arguments\n                \u2502   \u2502       \u251c\u2500\u2500 Function:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: calculate\n                \u2502   \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502           \u251c\u2500\u2500 Identifier: f\n                \u2502   \u2502           \u2514\u2500\u2500 Identifier: flag\n                \u251c\u2500\u2500 VarDeclaration: fact5 of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FunctionCall with 1 arguments\n                \u2502   \u2502       \u251c\u2500\u2500 Function:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: factorial\n                \u2502   \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u2514\u2500\u2500 IntegerLiteral: 5\n                \u251c\u2500\u2500 VarDeclaration: exprWithCall of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '+'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: a\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 FunctionCall with 1 arguments\n                \u2502   \u2502               \u251c\u2500\u2500 Function:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: factorial\n                \u2502   \u2502               \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 3\n                \u251c\u2500\u2500 VarDeclaration: nestedCall of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FunctionCall with 2 arguments\n                \u2502   \u2502       \u251c\u2500\u2500 Function:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: max\n                \u2502   \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u251c\u2500\u2500 FunctionCall with 1 arguments\n                \u2502   \u2502           \u2502   \u251c\u2500\u2500 Function:\n                \u2502   \u2502           \u2502   \u2502   \u251c\u2500\u2500 Identifier: factorial\n                \u2502   \u2502           \u2502   \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u2502       \u2514\u2500\u2500 IntegerLiteral: 2\n                \u2502   \u2502           \u2514\u2500\u2500 FunctionCall with 1 arguments\n                \u2502   \u2502               \u251c\u2500\u2500 Function:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: factorial\n                \u2502   \u2502               \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 3\n                \u251c\u2500\u2500 VarDeclaration: maxArrayValue of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 FunctionCall with 2 arguments\n                \u2502   \u2502       \u251c\u2500\u2500 Function:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 Identifier: max\n                \u2502   \u2502       \u2514\u2500\u2500 Arguments:\n                \u2502   \u2502           \u251c\u2500\u2500 ArrayAccess\n                \u2502   \u2502           \u2502   \u251c\u2500\u2500 Array:\n                \u2502   \u2502           \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502           \u2502   \u2514\u2500\u2500 Index:\n                \u2502   \u2502           \u2502       \u2514\u2500\u2500 IntegerLiteral: 1\n                \u2502   \u2502           \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502               \u251c\u2500\u2500 Array:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502               \u2514\u2500\u2500 Index:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 3\n                \u251c\u2500\u2500 IfStatement\n                \u2502   \u251c\u2500\u2500 Condition:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&gt;'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502   \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 0\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502               \u251c\u2500\u2500 Array:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502               \u2514\u2500\u2500 Index:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 1\n                \u2502   \u251c\u2500\u2500 ThenBlock:\n                \u2502   \u2502   \u251c\u2500\u2500 Block with 1 items\n                \u2502   \u2502   \u2502   \u2514\u2500\u2500 ExpressionStatement\n                \u2502   \u2502   \u2502       \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502   \u2502   \u2502           \u251c\u2500\u2500 Left:\n                \u2502   \u2502   \u2502           \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502   \u2502   \u2502           \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502   \u2502   \u2502           \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502   \u2502           \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502   \u2502   \u2502           \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 2\n                \u2502   \u2502   \u2502           \u2514\u2500\u2500 Right:\n                \u2502   \u2502   \u2502               \u2514\u2500\u2500 ArrayAccess\n                \u2502   \u2502   \u2502                   \u251c\u2500\u2500 Array:\n                \u2502   \u2502   \u2502                   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502   \u2502                   \u2514\u2500\u2500 Index:\n                \u2502   \u2502   \u2502                       \u2514\u2500\u2500 IntegerLiteral: 0\n                \u2502   \u2514\u2500\u2500 ElseBlock:\n                \u2502       \u2514\u2500\u2500 Block with 1 items\n                \u2502           \u2514\u2500\u2500 ExpressionStatement\n                \u2502               \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502                   \u251c\u2500\u2500 Left:\n                \u2502                   \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502                   \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502                   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502                   \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502                   \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 2\n                \u2502                   \u2514\u2500\u2500 Right:\n                \u2502                       \u2514\u2500\u2500 ArrayAccess\n                \u2502                           \u251c\u2500\u2500 Array:\n                \u2502                           \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502                           \u2514\u2500\u2500 Index:\n                \u2502                               \u2514\u2500\u2500 IntegerLiteral: 1\n                \u251c\u2500\u2500 VarDeclaration: j of type int\n                \u2502   \u251c\u2500\u2500 Initializer:\n                \u2502   \u2502   \u2514\u2500\u2500 IntegerLiteral: 0\n                \u251c\u2500\u2500 WhileStatement\n                \u2502   \u251c\u2500\u2500 Condition:\n                \u2502   \u2502   \u2514\u2500\u2500 BinaryExpression: '&amp;&amp;'\n                \u2502   \u2502       \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u251c\u2500\u2500 BinaryExpression: '&lt;'\n                \u2502   \u2502       \u2502   \u2502   \u251c\u2500\u2500 Left:\n                \u2502   \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: j\n                \u2502   \u2502       \u2502   \u2502   \u2514\u2500\u2500 Right:\n                \u2502   \u2502       \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 5\n                \u2502   \u2502       \u2514\u2500\u2500 Right:\n                \u2502   \u2502           \u2514\u2500\u2500 BinaryExpression: '&lt;'\n                \u2502   \u2502               \u251c\u2500\u2500 Left:\n                \u2502   \u2502               \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502   \u2502               \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502   \u2502               \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502   \u2502               \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502   \u2502               \u2502   \u2502       \u2514\u2500\u2500 Identifier: j\n                \u2502   \u2502               \u2514\u2500\u2500 Right:\n                \u2502   \u2502                   \u2514\u2500\u2500 IntegerLiteral: 100\n                \u2502   \u2514\u2500\u2500 Body:\n                \u2502       \u2514\u2500\u2500 Block with 2 items\n                \u2502           \u251c\u2500\u2500 ExpressionStatement\n                \u2502           \u2502   \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502           \u2502       \u251c\u2500\u2500 Left:\n                \u2502           \u2502       \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502           \u2502       \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502           \u2502       \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502           \u2502       \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502           \u2502       \u2502   \u2502       \u2514\u2500\u2500 Identifier: j\n                \u2502           \u2502       \u2514\u2500\u2500 Right:\n                \u2502           \u2502           \u2514\u2500\u2500 BinaryExpression: '*'\n                \u2502           \u2502               \u251c\u2500\u2500 Left:\n                \u2502           \u2502               \u2502   \u251c\u2500\u2500 ArrayAccess\n                \u2502           \u2502               \u2502   \u2502   \u251c\u2500\u2500 Array:\n                \u2502           \u2502               \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                \u2502           \u2502               \u2502   \u2502   \u2514\u2500\u2500 Index:\n                \u2502           \u2502               \u2502   \u2502       \u2514\u2500\u2500 Identifier: j\n                \u2502           \u2502               \u2514\u2500\u2500 Right:\n                \u2502           \u2502                   \u2514\u2500\u2500 IntegerLiteral: 2\n                \u2502           \u2514\u2500\u2500 ExpressionStatement\n                \u2502               \u2514\u2500\u2500 BinaryExpression: '='\n                \u2502                   \u251c\u2500\u2500 Left:\n                \u2502                   \u2502   \u251c\u2500\u2500 Identifier: j\n                \u2502                   \u2514\u2500\u2500 Right:\n                \u2502                       \u2514\u2500\u2500 BinaryExpression: '+'\n                \u2502                           \u251c\u2500\u2500 Left:\n                \u2502                           \u2502   \u251c\u2500\u2500 Identifier: j\n                \u2502                           \u2514\u2500\u2500 Right:\n                \u2502                               \u2514\u2500\u2500 IntegerLiteral: 1\n                \u2514\u2500\u2500 ReturnStatement\n                    \u2514\u2500\u2500 BinaryExpression: '+'\n                        \u251c\u2500\u2500 Left:\n                        \u2502   \u251c\u2500\u2500 ArrayAccess\n                        \u2502   \u2502   \u251c\u2500\u2500 Array:\n                        \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                        \u2502   \u2502   \u2514\u2500\u2500 Index:\n                        \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 4\n                        \u2514\u2500\u2500 Right:\n                            \u2514\u2500\u2500 FunctionCall with 1 arguments\n                                \u251c\u2500\u2500 Function:\n                                \u2502   \u251c\u2500\u2500 Identifier: factorial\n                                \u2514\u2500\u2500 Arguments:\n                                    \u2514\u2500\u2500 BinaryExpression: '/'\n                                        \u251c\u2500\u2500 Left:\n                                        \u2502   \u251c\u2500\u2500 ArrayAccess\n                                        \u2502   \u2502   \u251c\u2500\u2500 Array:\n                                        \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: numbers\n                                        \u2502   \u2502   \u2514\u2500\u2500 Index:\n                                        \u2502   \u2502       \u2514\u2500\u2500 IntegerLiteral: 0\n                                        \u2514\u2500\u2500 Right:\n                                            \u2514\u2500\u2500 IntegerLiteral: 10\n</code></pre>"},{"location":"2-syntaxAnalyzer/syntaxAnalyzerWritingNotes/","title":"Notes during Syntax Analyzer build","text":"<p>Copied from BigCooker parser README.md and AST README.md. </p>"},{"location":"2-syntaxAnalyzer/syntaxAnalyzerWritingNotes/#how-to-write-ast-node-structs-from-grammar-file","title":"How to write AST node structs from grammar file","text":"<ol> <li>Read the grammar (<code>BigC.g4</code>), determine which nodes are necessary to build the AST </li> <li>Not all symbols in the grammar file qualify to be an AST node (in which case we'd have a concrete syntax tree like <code>artifact/cst.txt</code>)</li> <li>AST node types include those that are important to the program struture: statement, expression, type, block, terminals, etc. </li> <li>AST node types do not include: operation precedence, delimiters like ';', precedence grouping symbols like '(' or ')'</li> </ol> <p>The ast.go file contains all the node types we considered necessary to build the AST</p> <ol> <li>Determine if the node should be a <code>struct</code> or an <code>interface</code></li> <li>A struct when: simple, concrete, no need for extending, need to hold data, need to be embedded into other structs </li> <li>An interface when: polymorphic, needs extending to subclasses/subinterfaces</li> </ol> <p>Specific example of when to use struct vs interface is explained as comments in <code>ast.go</code> </p> <ol> <li>Model the grammar </li> </ol> <p>Write the structs/interfaces so that it models the structure of the grammar, adding any fields to hold metadata if need be (for example, <code>Line</code> and <code>Column</code> number is considered metadata about the token).</p> <p>If you have ever written Entity class to wrap around a database in Java Spring, this is a parallel of that. The structs/interfaces in <code>ast.go</code> is a wrapper around the grammar so that we can populate its fields with data later. </p> <ol> <li>Rinse and repeat until covered all rules</li> </ol>"},{"location":"2-syntaxAnalyzer/syntaxAnalyzerWritingNotes/#how-to-build-ast-from-grammar-after-having-ast-nodes-defined","title":"How to build AST from grammar (after having AST nodes defined)","text":"<ol> <li>Locate the relevant items in grammar and <code>ast.go</code>. For example, this rule in the grammar</li> </ol> <pre><code>program\n    : declaration* EOF\n    ;\n</code></pre> <p>corresponds to this struct in <code>ast.go</code>:</p> <pre><code>type Program struct {\n    BaseNode\n    Declarations []Declaration\n}\n</code></pre> <p>and now we need to implement their corresponding visitor method in <code>parser.go</code>:</p> <pre><code>func (v *ASTBuilder) VisitProgram(ctx *ProgramContext)\n</code></pre> <ol> <li>Find the common tokens and populate the data in these fields first </li> </ol> <p>Consider this rule:  <pre><code>declaration\n    : type arrayNotation? Identifier declarationRemainder\n    ;\n</code></pre></p> <p>Which could have been a regular variable declaration or an array declaration. The first step is to process the common <code>type</code> token first, after this is done, consume the next token and decide if it is an array declaration. </p> <ol> <li>Branching </li> </ol> <p>When standing at a decision point (ie. after processing <code>type</code> and have to decide if this is an array declaration), proceed to process each case using if-else. </p> <p>This is when grammar unambiguity proves to be very useful: if the grammar is ambiguous, you would need to implement lookahead logic to lookahead several tokens to have enough information to keep going. </p> <p>Once again, this is very formulaic and requires detailed handling. </p>"},{"location":"2-syntaxAnalyzer/syntaxAnalyzerWritingNotes/#helpful-resources","title":"Helpful resources","text":"<ul> <li>This guy explains and demonstrates CST, AST, and happen to also explain interpreting vs. compiling pretty well in the process. He uses lex/yacc though, so if you're only familiar with Antlr it takes some extra effort to learn lex/yacc.</li> <li>Listener vs. Visitor explanation</li> </ul>"},{"location":"3-semanticAnalyzer/interface/","title":"Semantic Analysis Interface","text":"<ul> <li>Input: Abstract Syntax Tree</li> <li>Output: Annotated Abstract Syntax Tree (with typing &amp; scoping)</li> </ul> <p>Source code repo: https://github.com/GoBigC/BigC/tree/main/pkg/semantic</p>"},{"location":"3-semanticAnalyzer/semanticAnalyzer/","title":"Overview of How The Analyzer Works","text":""},{"location":"3-semanticAnalyzer/semanticAnalyzer/#three-pass-approach","title":"Three-pass Approach","text":"<p>The analyzer uses the three-pass approach:</p> <ol> <li>First pass: visits all the leaf node of the AST and add all the symbols to the table.</li> <li>Second pass: Traverse the AST again and analyze it with the complete symbol table from the first pass.</li> <li>Third pass: Finalize array sizes to ensure that before we generate code, we know exactly how long the array should be.</li> </ol>"},{"location":"3-semanticAnalyzer/semanticAnalyzer/#why-the-thee-pass-approach","title":"Why The Thee-pass Approach?","text":"<p>The first iteration used a naive approach where the analyzer traverse the AST only once, adding symbols and scanning for errors along the way. But this poses 1 major issue. Look at the code snippet below</p> <pre><code>int main() {\n    int a = addInt(1,2);\n    return a;\n}\n\nint addInt(int x, int y) {\n    return x + y;\n}\n</code></pre> <p>Intuitively, this code has no problems whatsoever (by design). However, the first iteration of semantic analyzers screams at me when it scans the code, saying that <code>addInt is an invalid symbol!</code>. Let this be an exercise to the reader to figure out why the first version of semantic analyzers hate this snippet. This is a very character-developing exercise, trust me.</p> <p>If you dislike brain exercises, bonkers. The answer is that at the time <code>addInt</code> was called at <code>int a = addInt(1,2);</code>, the symbol was not added to the table, simply because the analyzer traverses from the root up (or down?), and the function was declared after the function call. The two-pass approach was an easy solution.</p> <p>The third pass prevents this sort of behavior:</p> <pre><code>int a = scanf();\nchar arr[a];\n</code></pre> <p>which allows array size to be determined at runtime. Allocating memory at runtime is something we are not supporting right now. BigC requires all array size be compile-time constant expressions, meaning the exact size of all arrays must be known at compilation.</p>"},{"location":"3-semanticAnalyzer/semanticAnalyzer/#brief-explanation-of-how-each-semantic-error-is-caught","title":"Brief Explanation of How Each Semantic Error is Caught","text":""},{"location":"3-semanticAnalyzer/semanticAnalyzer/#index-out-of-bound","title":"Index Out of Bound","text":"<p>The array size is stored as a field in the symbol table, so the check is quite straight forward. If the index is a variable, the value of the variable is also checked to scan for out of bounds error.</p> <pre><code>int arr[5];\nint x = arr[7]; // ERROR\n\nint y = 7;\nint z = arr[y]; // ALSO ERROR\n</code></pre>"},{"location":"3-semanticAnalyzer/semanticAnalyzer/#divide-by-zero","title":"Divide by Zero","text":"<p>Whenever the <code>/</code> operator is called, we check if the second operand is a zero or not. If yes, we throw the error.</p>"},{"location":"3-semanticAnalyzer/semanticAnalyzer/#type-mismatch","title":"Type Mismatch","text":""},{"location":"3-semanticAnalyzer/semanticAnalyzer/#assignment-type-mismatch","title":"Assignment Type Mismatch","text":"<p>We check if the type in the declaration and the initializer matches or not. The type is inferred from the syntax analysis, so the check is very straightforward.</p>"},{"location":"3-semanticAnalyzer/semanticAnalyzer/#function-return-type-mismatch","title":"Function Return Type Mismatch","text":"<p>The return type for a function is stored in the symbol table, so this check is also simple.</p>"},{"location":"3-semanticAnalyzer/semanticAnalyzer/#operator-type-mismatch","title":"Operator Type Mismatch","text":"<p>Whenever an operator is called, we check the type of both operands.</p> <ul> <li>Logical operators only allow boolean expressions</li> <li>Numerical operators only allow <code>int</code> or <code>float</code>, and both operators must be the same type (we don't support type conversions yet)</li> </ul>"},{"location":"3-semanticAnalyzer/semanticAnalyzer/#function-argument-type-mismatch","title":"Function Argument Type Mismatch","text":"<p>The arguments in each function are also stored in the symbol table with their type, so the check is similar to other checks above.</p>"},{"location":"3-semanticAnalyzer/semanticAnalyzer/#invalid-function","title":"Invalid Function","text":""},{"location":"3-semanticAnalyzer/semanticAnalyzer/#argument-count-mismatch","title":"Argument Count Mismatch","text":"<p>The parameters are kept inside an array, so we only need to compare the length of the arguments array and the parameters array.</p>"},{"location":"3-semanticAnalyzer/semanticAnalyzer/#undefined-symbol","title":"Undefined Symbol","text":"<p>The table is a list of maps, so each variable is assigned a name, and looking up for the symbols is just using the map's query. For variables with the same name but different scope, the key for them will be determined by their scope. Each symbol's key will have a prefix based on the function that they are stored within.</p> <pre><code>int addInt(int x, int y) {\n    return x + y; // addInt.x and addInt.y respectively.\n}\n</code></pre>"},{"location":"3-semanticAnalyzer/semanticAnalyzer/#symbol-out-of-scope","title":"Symbol Out of Scope","text":"<p>The valid first line and valid last line of a symbol is stored in the table, so we just check if the line from which the symbol is called fits between the allowed lines.</p>"},{"location":"3-semanticAnalyzer/symbolTable/","title":"Structure of The Symbol Table","text":"Name Type Scope Array Size Value Parameters Return Type Identifier for symbol Type of symbol (int, function, ...) Size of array, null if symbol is not array Value of the symbol, if initialized The list of parameters if the symbol is a function Return type of the symbol if it is a function"},{"location":"3-semanticAnalyzer/symbolTable/#list-of-caught-semantic-errors","title":"List of Caught Semantic Errors","text":"<ol> <li>Index out of bound</li> <li>Divide by zero</li> <li> <p>Type mismatch:</p> </li> <li> <p>Assignment type mismatch</p> </li> <li>Function return type mismatch</li> <li>Operator type mismatch</li> <li> <p>Function argument type mismatch</p> </li> <li> <p>Invalid function</p> </li> <li> <p>Argument count mismatch</p> </li> <li> <p>Undefined symbol</p> </li> <li>Variable out of scope</li> </ol>"},{"location":"4-codeGenerator/interface/","title":"Code Generator Interface","text":"<ul> <li>Input: Annotated Abstract Syntax Tree </li> <li>Output: Bare-metal RISC-V assembly</li> </ul> <p>Source code repo: https://github.com/GoBigC/BigC/tree/main/pkg/codegen </p> <p>We generate bare-metal RISC-V assembly, meaning it probably will not work on any OS. The resulting assembly code would be run on RARS the RISC-V assembler simulator. </p>"},{"location":"4-codeGenerator/registerDefinitions/","title":"Register Definitions","text":"<p>Copied from https://msyksphinz-self.github.io/riscv-isadoc/html/regs.html</p>"},{"location":"4-codeGenerator/registerDefinitions/#integer-registers","title":"Integer Registers","text":"Register ABI Name Description Saver x0 zero Hard-wired zero x1 ra Return address Caller x2 sp Stack pointer Callee x3 gp Global pointer x4 tp Thread pointer x5 t0 Temporary/alternate link register Caller x6 t1 Temporaries Caller x7 t2 Temporaries Caller x8 s0/fp Saved register/frame pointer Callee x9 s1 Saved register Callee x10 a0 Function arguments/return values Caller x11 a1 Function arguments/return values Caller x12 a2 Function arguments Caller x13 a3 Function arguments Caller x14 a4 Function arguments Caller x15 a5 Function arguments Caller x16 a6 Function arguments Caller x17 a7 Function arguments Caller x18 s2 Saved registers Callee x19 s3 Saved registers Callee x20 s4 Saved registers Callee x21 s5 Saved registers Callee x22 s6 Saved registers Callee x23 s7 Saved registers Callee x24 s8 Saved registers Callee x25 s9 Saved registers Callee x26 s10 Saved registers Callee x27 s11 Saved registers Callee x28 t3 Temporaries Caller x29 t4 Temporaries Caller x30 t5 Temporaries Caller x31 t6 Temporaries Caller"},{"location":"4-codeGenerator/registerDefinitions/#floating-point-registers","title":"Floating Point Registers","text":"Register ABI Name Description Saver f0 ft0 FP temporaries Caller f1 ft1 FP temporaries Caller f2 ft2 FP temporaries Caller f3 ft3 FP temporaries Caller f4 ft4 FP temporaries Caller f5 ft5 FP temporaries Caller f6 ft6 FP temporaries Caller f7 ft7 FP temporaries Caller f8 fs0 FP saved registers Callee f9 fs1 FP saved registers Callee f10 fa0 FP arguments/return values Caller f11 fa1 FP arguments/return values Caller f12 fa2 FP arguments Caller f13 fa3 FP arguments Caller f14 fa4 FP arguments Caller f15 fa5 FP arguments Caller f16 fa6 FP arguments Caller f17 fa7 FP arguments Caller f18 fs2 FP saved registers Callee f19 fs3 FP saved registers Callee f20 fs4 FP saved registers Callee f21 fs5 FP saved registers Callee f22 fs6 FP saved registers Callee f23 fs7 FP saved registers Callee f24 fs8 FP saved registers Callee f25 fs9 FP saved registers Callee f26 fs10 FP saved registers Callee f27 fs11 FP saved registers Callee f28 ft8 FP temporaries Caller f29 ft9 FP temporaries Caller f30 ft10 FP temporaries Caller f31 ft11 FP temporaries Caller"},{"location":"4-codeGenerator/riscvModes/","title":"RARS setup","text":"<p>tl;dr: Make sure your RARS support these extensions: RV64I, RV64M, RV64D.</p> <p>BigC was developed to work with instruction set provided by RARS - the Risc-V Assembler and Runtime Simulator. To install RARS, head to its active repository. </p> <p>RISC-V support 32-bit and 64-bit mode. To support floating-point numbers, we are limited to 64-bit mode. From now on, all of our discussions regarding RISC-V only refer to 64-bit mode, which would be abbreviated to \"RV64\". </p>"},{"location":"4-codeGenerator/riscvModes/#understanding-rv64-modes","title":"Understanding RV64 modes","text":"<p>RV64 have several support modules, each called \"extension\".  1. Integer (I): Integer instructions.  2. Mumtiplication (M): Integer multiplication/division instructions. 3. Single-precision floating point (F): Single-precision floating point operations. 4. Double-precision floating point (D): Double-precision floating point operations. Note that this extension is a superset of RV64F.  5. Atomic (A): Atomic memory operations, necessary if support multi-threading, thread synchronization mechanisms (ie. locks).  6. Compressed (C): Compressed instructions, necessary to reduce code size for optimization. </p>"},{"location":"4-codeGenerator/riscvModes/#modes-relevant-to-bigc-development","title":"Modes relevant to BigC development","text":"<p>BigC is a simple language, currently in its infancy. Therefore, we do not support advanced functionalities like thread synchronization. For now, we also don't care too much about code optimization. </p> <p>So, 2 extensions are not needed: RV64A, RV64C. </p> <p>And these are the extensions needed: RV64I, RV64M, RV64D. </p> <p>You should check if your instance of RARS has all the necessary extensions. Test if this program can be assembled without any errors: </p> <pre><code>.text\nmain:\n    # Test RV64I (base 64-bit integer)\n    li t0, 0x123456789ABCDEF0  # 64-bit immediate load\n    addiw t1, t0, 10           # Add immediate, 32-bit result, sign-extend to 64-bit\n\n    # Test RV64M (integer multiplication/division)\n    li t2, 5\n    li t3, 7\n    mul t4, t2, t3             # Basic multiplication\n    mulh t5, t2, t3            # High bits of multiplication\n    div t6, t3, t2             # Division\n\n    # Test RV64D (double-precision floating point)\n    .data\n    double_val: .double 3.14159265358979\n    .text\n    la t0, double_val\n    fld f1, 0(t0)              # Load double\n    fmv.d.x f2, t0             # Move from integer to double\n    fadd.d f3, f1, f2          # Add doubles\n\n    # Exit program\n    li a0, 0\n    li a7, 10\n    ecall\n</code></pre>"},{"location":"4-codeGenerator/rv64d/","title":"RISC-V RV64D Instruction Set","text":"<p>Copied from https://msyksphinz-self.github.io/riscv-isadoc/html/rvfd.html and https://msyksphinz-self.github.io/riscv-isadoc/html/rv64d.html.</p>"},{"location":"4-codeGenerator/rv64d/#fmaddd","title":"fmadd.d","text":"<p>Format: <code>fmadd.d rd,rs1,rs2,rs3</code></p> <p>Description: Perform double-precision fused multiply addition.</p> <p>Implementation: <code>f[rd] = f[rs1]\u00d7f[rs2]+f[rs3]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n|-----|-----|-----|-----|-----|-----|-----|---|\n|rs3  |01   |rs2  |rs1  |rm   |rd   |10000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fmsubd","title":"fmsub.d","text":"<p>Format: <code>fmsub.d rd,rs1,rs2,rs3</code></p> <p>Description: Perform double-precision fused multiply subtraction.</p> <p>Implementation: <code>f[rd] = f[rs1]\u00d7f[rs2]-f[rs3]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|rs3  |01   |rs2  |rs1  |rm   |rd   |10001|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fnmsubd","title":"fnmsub.d","text":"<p>Format: <code>fnmsub.d rd,rs1,rs2,rs3</code></p> <p>Description: Perform double-precision negated fused multiply subtraction.</p> <p>Implementation: <code>f[rd] = -f[rs1]\u00d7f[rs2]+f[rs3]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|rs3  |01   |rs2  |rs1  |rm   |rd   |10010|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fnmaddd","title":"fnmadd.d","text":"<p>Format: <code>fnmadd.d rd,rs1,rs2,rs3</code></p> <p>Description: Perform double-precision negated fused multiply addition.</p> <p>Implementation: <code>f[rd] = -f[rs1]\u00d7f[rs2]-f[rs3]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|rs3  |01   |rs2  |rs1  |rm   |rd   |10011|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#faddd","title":"fadd.d","text":"<p>Format: <code>fadd.d rd,rs1,rs2</code></p> <p>Description: Perform double-precision floating-point addition.</p> <p>Implementation: <code>f[rd] = f[rs1] + f[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fsubd","title":"fsub.d","text":"<p>Format: <code>fsub.d rd,rs1,rs2</code></p> <p>Description: Perform double-precision floating-point subtraction.</p> <p>Implementation: <code>f[rd] = f[rs1] - f[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00001|01   |rs2  |rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fmuld","title":"fmul.d","text":"<p>Format: <code>fmul.d rd,rs1,rs2</code></p> <p>Description: Perform double-precision floating-point multiplication.</p> <p>Implementation: <code>f[rd] = f[rs1] \u00d7 f[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00010|01   |rs2  |rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fdivd","title":"fdiv.d","text":"<p>Format: <code>fdiv.d rd,rs1,rs2</code></p> <p>Description: Perform double-precision floating-point division.</p> <p>Implementation: <code>f[rd] = f[rs1] / f[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00011|01   |rs2  |rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fsqrtd","title":"fsqrt.d","text":"<p>Format: <code>fsqrt.d rd,rs1</code></p> <p>Description: Perform double-precision square root.</p> <p>Implementation: <code>f[rd] = sqrt(f[rs1])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01011|01   |00000|rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fsgnjd","title":"fsgnj.d","text":"<p>Format: <code>fsgnj.d rd,rs1,rs2</code></p> <p>Description: Produce a result that takes all bits except the sign bit from rs1. The result's sign bit is rs2's sign bit.</p> <p>Implementation: <code>f[rd] = {f[rs2][63], f[rs1][62:0]}</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00100|01   |rs2  |rs1  |000  |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fsgnjnd","title":"fsgnjn.d","text":"<p>Format: <code>fsgnjn.d rd,rs1,rs2</code></p> <p>Description: Produce a result that takes all bits except the sign bit from rs1. The result's sign bit is opposite of rs2's sign bit.</p> <p>Implementation: <code>f[rd] = {~f[rs2][63], f[rs1][62:0]}</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00100|01   |rs2  |rs1  |001  |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fsgnjxd","title":"fsgnjx.d","text":"<p>Format: <code>fsgnjx.d rd,rs1,rs2</code></p> <p>Description: Produce a result that takes all bits except the sign bit from rs1. The result's sign bit is XOR of sign bit of rs1 and rs2.</p> <p>Implementation: <code>f[rd] = {f[rs1][63] ^ f[rs2][63], f[rs1][62:0]}</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00100|01   |rs2  |rs1  |010  |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fmind","title":"fmin.d","text":"<p>Format: <code>fmin.d rd,rs1,rs2</code></p> <p>Description: Write the smaller of double precision data in rs1 and rs2 to rd.</p> <p>Implementation: <code>f[rd] = min(f[rs1], f[rs2])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00101|01   |rs2  |rs1  |000  |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fmaxd","title":"fmax.d","text":"<p>Format: <code>fmax.d rd,rs1,rs2</code></p> <p>Description: Write the larger of double precision data in rs1 and rs2 to rd.</p> <p>Implementation: <code>f[rd] = max(f[rs1], f[rs2])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00101|01   |rs2  |rs1  |001  |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fcvtsd","title":"fcvt.s.d","text":"<p>Format: <code>fcvt.s.d rd,rs1</code></p> <p>Description: Converts double floating-point register in rs1 into a single-precision floating-point number in floating-point register rd.</p> <p>Implementation: <code>f[rd] = f32_{f64}(f[rs1])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|00   |00001|rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fcvtds","title":"fcvt.d.s","text":"<p>Format: <code>fcvt.d.s rd,rs1</code></p> <p>Description: Converts single floating-point register in rs1 into a double floating-point number in floating-point register rd.</p> <p>Implementation: <code>f[rd] = f64_{f32}(f[rs1])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|01   |00000|rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#feqd","title":"feq.d","text":"<p>Format: <code>feq.d rd,rs1,rs2</code></p> <p>Description: Performs a quiet equal comparison between floating-point registers rs1 and rs2 and record the Boolean result in integer register rd. Only signaling NaN inputs cause an Invalid Operation exception. The result is 0 if either operand is NaN.</p> <p>Implementation: <code>x[rd] = f[rs1] == f[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|10100|01   |rs2  |rs1  |010  |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fltd","title":"flt.d","text":"<p>Format: <code>flt.d rd,rs1,rs2</code></p> <p>Description: Performs a quiet less-than comparison between floating-point registers rs1 and rs2 and record the Boolean result in integer register rd. Only signaling NaN inputs cause an Invalid Operation exception. The result is 0 if either operand is NaN.</p> <p>Implementation: <code>x[rd] = f[rs1] &lt; f[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|10100|01   |rs2  |rs1  |001  |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fled","title":"fle.d","text":"<p>Format: <code>fle.d rd,rs1,rs2</code></p> <p>Description: Performs a quiet less-than-or-equal comparison between floating-point registers rs1 and rs2 and record the Boolean result in integer register rd. Only signaling NaN inputs cause an Invalid Operation exception. The result is 0 if either operand is NaN.</p> <p>Implementation: <code>x[rd] = f[rs1] &lt;= f[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|10100|01   |rs2  |rs1  |000  |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fclassd","title":"fclass.d","text":"<p>Format: <code>fclass.d rd,rs1</code></p> <p>Description: Examines the value in floating-point register rs1 and writes to integer register rd a 10-bit mask that indicates the class of the floating-point number. The corresponding bit in rd will be set if the property is true and clear otherwise. All other bits in rd are cleared. Note that exactly one bit in rd will be set.</p> <p>Implementation: <code>x[rd] = classifyd(f[rs1])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|11100|01   |00000|rs1  |001  |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fcvtwd","title":"fcvt.w.d","text":"<p>Format: <code>fcvt.w.d rd,rs1</code></p> <p>Description: Converts a double-precision floating-point number in floating-point register rs1 to a signed 32-bit integer, in integer register rd.</p> <p>Implementation: <code>x[rd] = sext(s32_{f64}(f[rs1]))</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|11000|01   |00000|rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fcvtwud","title":"fcvt.wu.d","text":"<p>Format: <code>fcvt.wu.d rd,rs1</code></p> <p>Description: Converts a double-precision floating-point number in floating-point register rs1 to an unsigned 32-bit integer, in integer register rd.</p> <p>Implementation: <code>x[rd] = sext(u32_{f64}(f[rs1]))</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|11000|01   |00001|rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fcvtdw","title":"fcvt.d.w","text":"<p>Format: <code>fcvt.d.w rd,rs1</code></p> <p>Description: Converts a 32-bit signed integer, in integer register rs1 into a double-precision floating-point number in floating-point register rd.</p> <p>Implementation: <code>f[rd] = f64_{s32}(x[rs1])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|11010|01   |00000|rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fcvtdwu","title":"fcvt.d.wu","text":"<p>Format: <code>fcvt.d.wu rd,rs1</code></p> <p>Description: Converts a 32-bit unsigned integer, in integer register rs1 into a double-precision floating-point number in floating-point register rd.</p> <p>Implementation: <code>f[rd] = f64_{u32}(x[rs1])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|11010|01   |00001|rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fld","title":"fld","text":"<p>Format: <code>fld rd,offset(rs1)</code></p> <p>Description: Load a double-precision floating-point value from memory into floating-point register rd.</p> <p>Implementation: <code>f[rd] = M[x[rs1] + sext(offset)][63:0]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |011  |rd   |00001|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fsd","title":"fsd","text":"<p>Format: <code>fsd rs2,offset(rs1)</code></p> <p>Description: Store a double-precision value from the floating-point registers to memory.</p> <p>Implementation: <code>M[x[rs1] + sext(offset)] = f[rs2][63:0]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+--------+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7    |6-2  |1-0|\n+-----+-----+-----+-----+-----+--------+-----+---+\n|imm[11:5]  |rs2  |rs1  |011  |imm[4:0]|01001|11 |\n+-----+-----+-----+-----+-----+--------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fcvtld","title":"fcvt.l.d","text":"<p>Format: <code>fcvt.l.d rd,rs1</code></p> <p>Description: Converts a double-precision floating-point value to a 64-bit signed integer.</p> <p>Implementation: <code>x[rd] = s64_{f64}(f[rs1])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|11000|01   |00010|rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fcvtlud","title":"fcvt.lu.d","text":"<p>Format: <code>fcvt.lu.d rd,rs1</code></p> <p>Description: Converts a double-precision floating-point value to a 64-bit unsigned integer.</p> <p>Implementation: <code>x[rd] = u64_{f64}(f[rs1])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|11000|01   |00011|rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fmvxd","title":"fmv.x.d","text":"<p>Format: <code>fmv.x.d rd,rs1</code></p> <p>Description: Moves the double-precision value from floating-point register to integer register.</p> <p>Implementation: <code>x[rd] = f[rs1][63:0]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|11100|01   |00000|rs1  |000  |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fcvtdl","title":"fcvt.d.l","text":"<p>Format: <code>fcvt.d.l rd,rs1</code></p> <p>Description: Converts a 64-bit signed integer to a double-precision floating-point value.</p> <p>Implementation: <code>f[rd] = f64_{s64}(x[rs1])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|11010|01   |00010|rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fcvtdlu","title":"fcvt.d.lu","text":"<p>Format: <code>fcvt.d.lu rd,rs1</code></p> <p>Description: Converts a 64-bit unsigned integer to a double-precision floating-point value.</p> <p>Implementation: <code>f[rd] = f64_{u64}(x[rs1])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|11010|01   |00011|rs1  |rm   |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#fmvdx","title":"fmv.d.x","text":"<p>Format: <code>fmv.d.x rd,rs1</code></p> <p>Description: Moves the 64-bit integer from integer register to floating-point register.</p> <p>Implementation: <code>f[rd] = x[rs1][63:0]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|11110|01   |00000|rs1  |000  |rd   |10100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64d/#floating-point-classification","title":"Floating-Point Classification","text":"<p>The <code>fclass.d</code> instruction sets bits in the destination register according to this table:</p> rd bit Meaning 0 rs1 is -infinity 1 rs1 is a negative normal number 2 rs1 is a negative subnormal number 3 rs1 is \u22120 4 rs1 is +0 5 rs1 is a positive subnormal number 6 rs1 is a positive normal number 7 rs1 is +infinity 8 rs1 is a signaling NaN 9 rs1 is a quiet NaN"},{"location":"4-codeGenerator/rv64i/","title":"RISC-V RV64I Instruction Set","text":"<p>Copied from https://msyksphinz-self.github.io/riscv-isadoc/html/rvi.html and https://msyksphinz-self.github.io/riscv-isadoc/html/rv64i.html.</p>"},{"location":"4-codeGenerator/rv64i/#addiw","title":"addiw","text":"<p>Format: <code>addiw rd,rs1,imm</code></p> <p>Description: Adds the sign-extended 12-bit immediate to register rs1 and produces the proper sign-extension of a 32-bit result in rd. Overflows are ignored and the result is the low 32 bits of the result sign-extended to 64 bits. Note, ADDIW rd, rs1, 0 writes the sign-extension of the lower 32 bits of register rs1 into register rd (assembler pseudoinstruction SEXT.W).</p> <p>Implementation: <code>x[rd] = sext((x[rs1] + sext(immediate))[31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |000  |rd   |00110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#slliw","title":"slliw","text":"<p>Format: <code>slliw rd,rs1,shamt</code></p> <p>Description: Performs logical left shift on the 32-bit of value in register rs1 by the shift amount held in the lower 5 bits of the immediate. Encodings with imm[5] \u2260 0 are reserved.</p> <p>Implementation: <code>x[rd] = sext((x[rs1] &lt;&lt; shamt)[31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |shamt|rs1  |001  |rd   |00110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#srliw","title":"srliw","text":"<p>Format: <code>srliw rd,rs1,shamt</code></p> <p>Description: Performs logical right shift on the 32-bit of value in register rs1 by the shift amount held in the lower 5 bits of the immediate. Encodings with imm[5] \u2260 0 are reserved.</p> <p>Implementation: <code>x[rd] = sext(x[rs1][31:0] &gt;&gt;u shamt)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |shamt|rs1  |101  |rd   |00110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sraiw","title":"sraiw","text":"<p>Format: <code>sraiw rd,rs1,shamt</code></p> <p>Description: Performs arithmetic right shift on the 32-bit of value in register rs1 by the shift amount held in the lower 5 bits of the immediate. Encodings with imm[5] \u2260 0 are reserved.</p> <p>Implementation: <code>x[rd] = sext(x[rs1][31:0] &gt;&gt;s shamt)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|00   |shamt|rs1  |101  |rd   |00110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#addw","title":"addw","text":"<p>Format: <code>addw rd,rs1,rs2</code></p> <p>Description: Adds the 32-bit of registers rs1 and 32-bit of register rs2 and stores the result in rd. Arithmetic overflow is ignored and the low 32-bits of the result is sign-extended to 64-bits and written to the destination register.</p> <p>Implementation: <code>x[rd] = sext((x[rs1] + x[rs2])[31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |000  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#subw","title":"subw","text":"<p>Format: <code>subw rd,rs1,rs2</code></p> <p>Description: Subtract the 32-bit of registers rs1 and 32-bit of register rs2 and stores the result in rd. Arithmetic overflow is ignored and the low 32-bits of the result is sign-extended to 64-bits and written to the destination register.</p> <p>Implementation: <code>x[rd] = sext((x[rs1] - x[rs2])[31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|00   |rs2  |rs1  |000  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sllw","title":"sllw","text":"<p>Format: <code>sllw rd,rs1,rs2</code></p> <p>Description: Performs logical left shift on the low 32-bits value in register rs1 by the shift amount held in the lower 5 bits of register rs2 and produce 32-bit results and written to the destination register rd.</p> <p>Implementation: <code>x[rd] = sext((x[rs1] &lt;&lt; x[rs2][4:0])[31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |001  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#srlw","title":"srlw","text":"<p>Format: <code>srlw rd,rs1,rs2</code></p> <p>Description: Performs logical right shift on the low 32-bits value in register rs1 by the shift amount held in the lower 5 bits of register rs2 and produce 32-bit results and written to the destination register rd.</p> <p>Implementation: <code>x[rd] = sext(x[rs1][31:0] &gt;&gt;u x[rs2][4:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |101  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sraw","title":"sraw","text":"<p>Format: <code>sraw rd,rs1,rs2</code></p> <p>Description: Performs arithmetic right shift on the low 32-bits value in register rs1 by the shift amount held in the lower 5 bits of register rs2 and produce 32-bit results and written to the destination register rd.</p> <p>Implementation: <code>x[rd] = sext(x[rs1][31:0] &gt;&gt;s x[rs2][4:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|00   |rs2  |rs1  |101  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#lwu","title":"lwu","text":"<p>Format: <code>lwu rd,offset(rs1)</code></p> <p>Description: Loads a 32-bit value from memory and zero-extends this to 64 bits before storing it in register rd.</p> <p>Implementation: <code>x[rd] = M[x[rs1] + sext(offset)][31:0]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |110  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#ld","title":"ld","text":"<p>Format: <code>ld rd,offset(rs1)</code></p> <p>Description: Loads a 64-bit value from memory into register rd for RV64I.</p> <p>Implementation: <code>x[rd] = M[x[rs1] + sext(offset)][63:0]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |011  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sd","title":"sd","text":"<p>Format: <code>sd rs2,offset(rs1)</code></p> <p>Description: Store 64-bit, values from register rs2 to memory.</p> <p>Implementation: <code>M[x[rs1] + sext(offset)] = x[rs2][63:0]</code></p> <p>Encoding: <pre><code>+-----+------+-----+-----+-----+-----------+-----+---+\n|31-27|26-25 |24-20|19-15|14-12|11-7       |6-2  |1-0|\n+-----+------+-----+-----+-----+-----------+-----+---+\n|offset[11:5]|rs2  |rs1  |011  |offset[4:0]|01000|11 |\n+-----+------+-----+-----+-----+-----------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#lui","title":"lui","text":"<p>Format: <code>lui rd,imm</code></p> <p>Description: Build 32-bit constants and uses the U-type format. LUI places the U-immediate value in the top 20 bits of the destination register rd, filling in the lowest 12 bits with zeros.</p> <p>Implementation: <code>x[rd] = sext(immediate[31:12] &lt;&lt; 12)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[31:12]                   |rd   |01101|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#auipc","title":"auipc","text":"<p>Format: <code>auipc rd,imm</code></p> <p>Description: Build pc-relative addresses and uses the U-type format. AUIPC forms a 32-bit offset from the 20-bit U-immediate, filling in the lowest 12 bits with zeros, adds this offset to the pc, then places the result in register rd.</p> <p>Implementation: <code>x[rd] = pc + sext(immediate[31:12] &lt;&lt; 12)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[31:12]                   |rd   |00101|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#addi","title":"addi","text":"<p>Format: <code>addi rd,rs1,imm</code></p> <p>Description: Adds the sign-extended 12-bit immediate to register rs1. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result. ADDI rd, rs1, 0 is used to implement the MV rd, rs1 assembler pseudo-instruction.</p> <p>Implementation: <code>x[rd] = x[rs1] + sext(immediate)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |000  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#slti","title":"slti","text":"<p>Format: <code>slti rd,rs1,imm</code></p> <p>Description: Place the value 1 in register rd if register rs1 is less than the signextended immediate when both are treated as signed numbers, else 0 is written to rd.</p> <p>Implementation: <code>x[rd] = x[rs1] &lt;s sext(immediate)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |010  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sltiu","title":"sltiu","text":"<p>Format: <code>sltiu rd,rs1,imm</code></p> <p>Description: Place the value 1 in register rd if register rs1 is less than the immediate when both are treated as unsigned numbers, else 0 is written to rd.</p> <p>Implementation: <code>x[rd] = x[rs1] &lt;u sext(immediate)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |011  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#xori","title":"xori","text":"<p>Format: <code>xori rd,rs1,imm</code></p> <p>Description: Performs bitwise XOR on register rs1 and the sign-extended 12-bit immediate and place the result in rd. Note, \"XORI rd, rs1, -1\" performs a bitwise logical inversion of register rs1(assembler pseudo-instruction NOT rd, rs)</p> <p>Implementation: <code>x[rd] = x[rs1] ^ sext(immediate)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |100  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#ori","title":"ori","text":"<p>Format: <code>ori rd,rs1,imm</code></p> <p>Description: Performs bitwise OR on register rs1 and the sign-extended 12-bit immediate and place the result in rd</p> <p>Implementation: <code>x[rd] = x[rs1] | sext(immediate)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |110  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#andi","title":"andi","text":"<p>Format: <code>andi rd,rs1,imm</code></p> <p>Description: Performs bitwise AND on register rs1 and the sign-extended 12-bit immediate and place the result in rd</p> <p>Implementation: <code>x[rd] = x[rs1] &amp; sext(immediate)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |111  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#slli","title":"slli","text":"<p>Format: <code>slli rd,rs1,shamt</code></p> <p>Description: Performs logical left shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate. In RV64, bit-25 is used to shamt[5].</p> <p>Implementation: <code>x[rd] = x[rs1] &lt;&lt; shamt</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|0X   |shamt|rs1  |001  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#srli","title":"srli","text":"<p>Format: <code>srli rd,rs1,shamt</code></p> <p>Description: Performs logical right shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate. In RV64, bit-25 is used to shamt[5].</p> <p>Implementation: <code>x[rd] = x[rs1] &gt;&gt;u shamt</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|0X   |shamt|rs1  |101  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#srai","title":"srai","text":"<p>Format: <code>srai rd,rs1,shamt</code></p> <p>Description: Performs arithmetic right shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate. In RV64, bit-25 is used to shamt[5].</p> <p>Implementation: <code>x[rd] = x[rs1] &gt;&gt;s shamt</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|0X   |shamt|rs1  |101  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#add","title":"add","text":"<p>Format: <code>add rd,rs1,rs2</code></p> <p>Description: Adds the registers rs1 and rs2 and stores the result in rd. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result.</p> <p>Implementation: <code>x[rd] = x[rs1] + x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |000  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sub","title":"sub","text":"<p>Format: <code>sub rd,rs1,rs2</code></p> <p>Description: Subs the register rs2 from rs1 and stores the result in rd. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result.</p> <p>Implementation: <code>x[rd] = x[rs1] - x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|00   |rs2  |rs1  |000  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sll","title":"sll","text":"<p>Format: <code>sll rd,rs1,rs2</code></p> <p>Description: Performs logical left shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.</p> <p>Implementation: <code>x[rd] = x[rs1] &lt;&lt; x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |001  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#slt","title":"slt","text":"<p>Format: <code>slt rd,rs1,rs2</code></p> <p>Description: Place the value 1 in register rd if register rs1 is less than register rs2 when both are treated as signed numbers, else 0 is written to rd.</p> <p>Implementation: <code>x[rd] = x[rs1] &lt;s x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |010  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sltu","title":"sltu","text":"<p>Format: <code>sltu rd,rs1,rs2</code></p> <p>Description: Place the value 1 in register rd if register rs1 is less than register rs2 when both are treated as unsigned numbers, else 0 is written to rd.</p> <p>Implementation: <code>x[rd] = x[rs1] &lt;u x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |011  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#xor","title":"xor","text":"<p>Format: <code>xor rd,rs1,rs2</code></p> <p>Description: Performs bitwise XOR on registers rs1 and rs2 and place the result in rd</p> <p>Implementation: <code>x[rd] = x[rs1] ^ x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |100  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#srl","title":"srl","text":"<p>Format: <code>srl rd,rs1,rs2</code></p> <p>Description: Logical right shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2</p> <p>Implementation: <code>x[rd] = x[rs1] &gt;&gt;u x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |101  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sra","title":"sra","text":"<p>Format: <code>sra rd,rs1,rs2</code></p> <p>Description: Performs arithmetic right shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2</p> <p>Implementation: <code>x[rd] = x[rs1] &gt;&gt;s x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|00   |rs2  |rs1  |101  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#or","title":"or","text":"<p>Format: <code>or rd,rs1,rs2</code></p> <p>Description: Performs bitwise OR on registers rs1 and rs2 and place the result in rd</p> <p>Implementation: <code>x[rd] = x[rs1] | x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |110  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#and","title":"and","text":"<p>Format: <code>and rd,rs1,rs2</code></p> <p>Description: Performs bitwise AND on registers rs1 and rs2 and place the result in rd</p> <p>Implementation: <code>x[rd] = x[rs1] &amp; x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |111  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#fence","title":"fence","text":"<p>Format: <code>fence pred, succ</code></p> <p>Description: Used to order device I/O and memory accesses as viewed by other RISC-V harts and external devices or coprocessors. Any combination of device input (I), device output (O), memory reads (R), and memory writes (W) may be ordered with respect to any combination of the same. Informally, no other RISC-V hart or external device can observe any operation in the successor set following a FENCE before any operation in the predecessor set preceding the FENCE.</p> <p>Implementation: <code>Fence(pred, succ)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-28|27-24|23-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|0000 |pred |succ |00000|000  |00000|00011|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#fencei","title":"fence.i","text":"<p>Format: <code>fence.i</code></p> <p>Description: Provides explicit synchronization between writes to instruction memory and instruction fetches on the same hart.</p> <p>Implementation: <code>Fence(Store, Fetch)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |00000|00000|001  |00000|00011|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#csrrw","title":"csrrw","text":"<p>Format: <code>csrrw rd,offset,rs1</code></p> <p>Description: Atomically swaps values in the CSRs and integer registers. CSRRW reads the old value of the CSR, zero-extends the value to XLEN bits, then writes it to integer register rd. The initial value in rs1 is written to the CSR. If rd=x0, then the instruction shall not read the CSR and shall not cause any of the side effects that might occur on a CSR read.</p> <p>Implementation: <code>t = CSRs[csr]; CSRs[csr] = x[rs1]; x[rd] = t</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|csr              |rs1  |001  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#csrrs","title":"csrrs","text":"<p>Format: <code>csrrs rd,offset,rs1</code></p> <p>Description: Reads the value of the CSR, zero-extends the value to XLEN bits, and writes it to integer register rd. The initial value in integer register rs1 is treated as a bit mask that specifies bit positions to be set in the CSR. Any bit that is high in rs1 will cause the corresponding bit to be set in the CSR, if that CSR bit is writable. Other bits in the CSR are unaffected (though CSRs might have side effects when written).</p> <p>Implementation: <code>t = CSRs[csr]; CSRs[csr] = t | x[rs1]; x[rd] = t</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|csr              |rs1  |010  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#csrrc","title":"csrrc","text":"<p>Format: <code>csrrc rd,offset,rs1</code></p> <p>Description: Reads the value of the CSR, zero-extends the value to XLEN bits, and writes it to integer register rd. The initial value in integer register rs1 is treated as a bit mask that specifies bit positions to be cleared in the CSR. Any bit that is high in rs1 will cause the corresponding bit to be cleared in the CSR, if that CSR bit is writable. Other bits in the CSR are unaffected.</p> <p>Implementation: <code>t = CSRs[csr]; CSRs[csr] = t &amp;\u223cx[rs1]; x[rd] = t</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|csr              |rs1  |011  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#csrrwi","title":"csrrwi","text":"<p>Format: <code>csrrwi rd,offset,uimm</code></p> <p>Description: Update the CSR using an XLEN-bit value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field encoded in the rs1 field.</p> <p>Implementation: <code>x[rd] = CSRs[csr]; CSRs[csr] = zimm</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|csr              |uimm |101  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#csrrsi","title":"csrrsi","text":"<p>Format: <code>csrrsi rd,offset,uimm</code></p> <p>Description: Set CSR bit using an XLEN-bit value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field encoded in the rs1 field.</p> <p>Implementation: <code>t = CSRs[csr]; CSRs[csr] = t | zimm; x[rd] = t</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|csr              |uimm |110  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#csrrci","title":"csrrci","text":"<p>Format: <code>csrrci rd,offset,uimm</code></p> <p>Description: Clear CSR bit using an XLEN-bit value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field encoded in the rs1 field.</p> <p>Implementation: <code>t = CSRs[csr]; CSRs[csr] = t &amp;\u223czimm; x[rd] = t</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|csr              |rs1  |111  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#ecall","title":"ecall","text":"<p>Format: <code>ecall</code></p> <p>Description: Make a request to the supporting execution environment. When executed in U-mode, S-mode, or M-mode, it generates an environment-call-from-U-mode exception, environment-call-from-S-mode exception, or environment-call-from-M-mode exception, respectively, and performs no other operation.</p> <p>Implementation: <code>RaiseException(EnvironmentCall)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |00000|00000|000  |00000|11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#ebreak","title":"ebreak","text":"<p>Format: <code>ebreak</code></p> <p>Description: Used by debuggers to cause control to be transferred back to a debugging environment. It generates a breakpoint exception and performs no other operation.</p> <p>Implementation: <code>RaiseException(Breakpoint)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |00001|00000|000  |00000|11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#uret","title":"uret","text":"<p>Format: <code>uret</code></p> <p>Description: Return from traps in U-mode, and URET copies UPIE into UIE, then sets UPIE.</p> <p>Implementation: <code>ExceptionReturn(User)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |00010|00000|000  |00000|11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sret","title":"sret","text":"<p>Format: <code>sret</code></p> <p>Description: Return from traps in S-mode, and SRET copies SPIE into SIE, then sets SPIE.</p> <p>Implementation: <code>ExceptionReturn(User)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00010|00   |00010|00000|000  |00000|11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#mret","title":"mret","text":"<p>Format: <code>mret</code></p> <p>Description: Return from traps in M-mode, and MRET copies MPIE into MIE, then sets MPIE.</p> <p>Implementation: <code>ExceptionReturn(Machine)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00110|00   |00010|00000|000  |00000|11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#wfi","title":"wfi","text":"<p>Format: <code>wfi</code></p> <p>Description: Provides a hint to the implementation that the current hart can be stalled until an interrupt might need servicing. Execution of the WFI instruction can also be used to inform the hardware platform that suitable interrupts should preferentially be routed to this hart. WFI is available in all privileged modes, and optionally available to U-mode. This instruction may raise an illegal instruction exception when TW=1 in mstatus.</p> <p>Implementation: <code>while (noInterruptsPending) idle</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00010|00   |00101|00000|000  |00000|11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sfencevma","title":"sfence.vma","text":"<p>Format: <code>sfence.vma rs1,rs2</code></p> <p>Description: Guarantees that any previous stores already visible to the current RISC-V hart are ordered before all subsequent implicit references from that hart to the memory-management data structures. The SFENCE.VMA is used to flush any local hardware caches related to address translation. It is specified as a fence rather than a TLB flush to provide cleaner semantics with respect to which instructions are affected by the flush operation and to support a wider variety of dynamic caching structures and memory-management schemes. SFENCE.VMA is also used by higher privilege levels to synchronize page table writes and the address translation hardware.</p> <p>Implementation: <code>Fence(Store, AddressTranslation)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00010|01   |rs2  |rs1  |000  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#lb","title":"lb","text":"<p>Format: <code>lb rd,offset(rs1)</code></p> <p>Description: Loads a 8-bit value from memory and sign-extends this to XLEN bits before storing it in register rd.</p> <p>Implementation: <code>x[rd] = sext(M[x[rs1] + sext(offset)][7:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |000  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#lh","title":"lh","text":"<p>Format: <code>lh rd,offset(rs1)</code></p> <p>Description: Loads a 16-bit value from memory and sign-extends this to XLEN bits before storing it in register rd.</p> <p>Implementation: <code>x[rd] = sext(M[x[rs1] + sext(offset)][15:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |001  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#lw","title":"lw","text":"<p>Format: <code>lw rd,offset(rs1)</code></p> <p>Description: Loads a 32-bit value from memory and sign-extends this to XLEN bits before storing it in register rd.</p> <p>Implementation: <code>x[rd] = sext(M[x[rs1] + sext(offset)][31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |010  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#lbu","title":"lbu","text":"<p>Format: <code>lbu rd,offset(rs1)</code></p> <p>Description: Loads a 8-bit value from memory and zero-extends this to XLEN bits before storing it in register rd.</p> <p>Implementation: <code>x[rd] = M[x[rs1] + sext(offset)][7:0]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |100  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#lhu","title":"lhu","text":"<p>Format: <code>lhu rd,offset(rs1)</code></p> <p>Description: Loads a 16-bit value from memory and zero-extends this to XLEN bits before storing it in register rd.</p> <p>Implementation: <code>x[rd] = M[x[rs1] + sext(offset)][15:0]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |101  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sb","title":"sb","text":"<p>Format: <code>sb rs2,offset(rs1)</code></p> <p>Description: Store 8-bit, values from the low bits of register rs2 to memory.</p> <p>Implementation: <code>M[x[rs1] + sext(offset)] = x[rs2][7:0]</code></p> <p>Encoding: <pre><code>+-----+------+-----+-----+-----+-----------+-----+---+\n|31-27|26-25 |24-20|19-15|14-12|11-7       |6-2  |1-0|\n+-----+------+-----+-----+-----+-----------+-----+---+\n|offset[11:5]|rs2  |rs1  |000  |offset[4:0]|01000|11 |\n+-----+------+-----+-----+-----+-----------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sh","title":"sh","text":"<p>Format: <code>sh rs2,offset(rs1)</code></p> <p>Description: Store 16-bit, values from the low bits of register rs2 to memory.</p> <p>Implementation: <code>M[x[rs1] + sext(offset)] = x[rs2][15:0]</code></p> <p>Encoding: <pre><code>+-----+------+-----+-----+-----+-----------+-----+---+\n|31-27|26-25 |24-20|19-15|14-12|11-7       |6-2  |1-0|\n+-----+------+-----+-----+-----+-----------+-----+---+\n|offset[11:5]|rs2  |rs1  |001  |offset[4:0]|01000|11 |\n+-----+------+-----+-----+-----+-----------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#sw","title":"sw","text":"<p>Format: <code>sw rs2,offset(rs1)</code></p> <p>Description: Store 32-bit, values from the low bits of register rs2 to memory.</p> <p>Implementation: <code>M[x[rs1] + sext(offset)] = x[rs2][31:0]</code></p> <p>Encoding: <pre><code>+-----+------+-----+-----+-----+-----------+-----+---+\n|31-27|26-25 |24-20|19-15|14-12|11-7       |6-2  |1-0|\n+-----+------+-----+-----+-----+-----------+-----+---+\n|offset[11:5]|rs2  |rs1  |010  |offset[4:0]|01000|11 |\n+-----+------+-----+-----+-----+-----------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#jal","title":"jal","text":"<p>Format: <code>jal rd,offset</code></p> <p>Description: Jump to address and place return address in rd.</p> <p>Implementation: <code>x[rd] = pc+4; pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[20|10:1|11|19:12]     |rd   |11011|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#jalr","title":"jalr","text":"<p>Format: <code>jalr rd,rs1,offset</code></p> <p>Description: Jump to address and place return address in rd.</p> <p>Implementation: <code>t =pc+4; pc=(x[rs1]+sext(offset))&amp;\u223c1; x[rd]=t</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |000  |rd   |11001|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#beq","title":"beq","text":"<p>Format: <code>beq rs1,rs2,offset</code></p> <p>Description: Take the branch if registers rs1 and rs2 are equal.</p> <p>Implementation: <code>if (x[rs1] == x[rs2]) pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+---------+-----+-----+-----+--------------+-----+---+\n|31-27|26-25    |24-20|19-15|14-12|11-7          |6-2  |1-0|\n+-----+---------+-----+-----+-----+--------------+-----+---+\n|offset[12|10:5]|rs2  |rs1  |000  |offset[4:1|11]|11000|11 |\n+-----+---------+-----+-----+-----+--------------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#bne","title":"bne","text":"<p>Format: <code>bne rs1,rs2,offset</code></p> <p>Description: Take the branch if registers rs1 and rs2 are not equal.</p> <p>Implementation: <code>if (x[rs1] != x[rs2]) pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+---------+-----+-----+-----+--------------+-----+---+\n|31-27|26-25    |24-20|19-15|14-12|11-7          |6-2  |1-0|\n+-----+---------+-----+-----+-----+--------------+-----+---+\n|offset[12|10:5]|rs2  |rs1  |001  |offset[4:1|11]|11000|11 |\n+-----+---------+-----+-----+-----+--------------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#blt","title":"blt","text":"<p>Format: <code>blt rs1,rs2,offset</code></p> <p>Description: Take the branch if registers rs1 is less than rs2, using signed comparison.</p> <p>Implementation: <code>if (x[rs1] &lt;s x[rs2]) pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+---------+-----+-----+-----+--------------+-----+---+\n|31-27|26-25    |24-20|19-15|14-12|11-7          |6-2  |1-0|\n+-----+---------+-----+-----+-----+--------------+-----+---+\n|offset[12|10:5]|rs2  |rs1  |100  |offset[4:1|11]|11000|11 |\n+-----+---------+-----+-----+-----+--------------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#bge","title":"bge","text":"<p>Format: <code>bge rs1,rs2,offset</code></p> <p>Description: Take the branch if registers rs1 is greater than or equal to rs2, using signed comparison.</p> <p>Implementation: <code>if (x[rs1] &gt;=s x[rs2]) pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+---------+-----+-----+-----+--------------+-----+---+\n|31-27|26-25    |24-20|19-15|14-12|11-7          |6-2  |1-0|\n+-----+---------+-----+-----+-----+--------------+-----+---+\n|offset[12|10:5]|rs2  |rs1  |101  |offset[4:1|11]|11000|11 |\n+-----+---------+-----+-----+-----+--------------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#bltu","title":"bltu","text":"<p>Format: <code>bltu rs1,rs2,offset</code></p> <p>Description: Take the branch if registers rs1 is less than rs2, using unsigned comparison.</p> <p>Implementation: <code>if (x[rs1] &lt;u x[rs2]) pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+---------+-----+-----+-----+--------------+-----+---+\n|31-27|26-25    |24-20|19-15|14-12|11-7          |6-2  |1-0|\n+-----+---------+-----+-----+-----+--------------+-----+---+\n|offset[12|10:5]|rs2  |rs1  |110  |offset[4:1|11]|11000|11 |\n+-----+---------+-----+-----+-----+--------------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64i/#bgeu","title":"bgeu","text":"<p>Format: <code>bgeu rs1,rs2,offset</code></p> <p>Description: Take the branch if registers rs1 is greater than or equal to rs2, using unsigned comparison.</p> <p>Implementation: <code>if (x[rs1] &gt;=u x[rs2]) pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+---------+-----+-----+-----+--------------+-----+---+\n|31-27|26-25    |24-20|19-15|14-12|11-7          |6-2  |1-0|\n+-----+---------+-----+-----+-----+--------------+-----+---+\n|offset[12|10:5]|rs2  |rs1  |111  |offset[4:1|11]|11000|11 |\n+-----+---------+-----+-----+-----+--------------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64m/","title":"RISC-V RV64M Instruction Set","text":"<p>Copied from https://msyksphinz-self.github.io/riscv-isadoc/html/rvm.html and https://msyksphinz-self.github.io/riscv-isadoc/html/rv64m.html</p>"},{"location":"4-codeGenerator/rv64m/#mul","title":"mul","text":"<p>Format: <code>mul rd,rs1,rs2</code></p> <p>Description: Performs an XLEN-bit \u00d7 XLEN-bit multiplication of signed rs1 by signed rs2 and places the lower XLEN bits in the destination register.</p> <p>Implementation: <code>x[rd] = x[rs1] \u00d7 x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |000  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64m/#mulh","title":"mulh","text":"<p>Format: <code>mulh rd,rs1,rs2</code></p> <p>Description: Performs an XLEN-bit \u00d7 XLEN-bit multiplication of signed rs1 by signed rs2 and places the upper XLEN bits in the destination register.</p> <p>Implementation: <code>x[rd] = (x[rs1] s\u00d7s x[rs2]) &gt;&gt;s XLEN</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |001  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64m/#mulhsu","title":"mulhsu","text":"<p>Format: <code>mulhsu rd,rs1,rs2</code></p> <p>Description: Performs an XLEN-bit \u00d7 XLEN-bit multiplication of signed rs1 by unsigned rs2 and places the upper XLEN bits in the destination register.</p> <p>Implementation: <code>x[rd] = (x[rs1] s\u00d7 x[rs2]) &gt;&gt;s XLEN</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |010  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64m/#mulhu","title":"mulhu","text":"<p>Format: <code>mulhu rd,rs1,rs2</code></p> <p>Description: Performs an XLEN-bit \u00d7 XLEN-bit multiplication of unsigned rs1 by unsigned rs2 and places the upper XLEN bits in the destination register.</p> <p>Implementation: <code>x[rd] = (x[rs1] u\u00d7 x[rs2]) &gt;&gt;u XLEN</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |011  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64m/#div","title":"div","text":"<p>Format: <code>div rd,rs1,rs2</code></p> <p>Description: Perform an XLEN bits by XLEN bits signed integer division of rs1 by rs2, rounding towards zero.</p> <p>Implementation: <code>x[rd] = x[rs1] /s x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |100  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64m/#divu","title":"divu","text":"<p>Format: <code>divu rd,rs1,rs2</code></p> <p>Description: Perform an XLEN bits by XLEN bits unsigned integer division of rs1 by rs2, rounding towards zero.</p> <p>Implementation: <code>x[rd] = x[rs1] /u x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |101  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64m/#rem","title":"rem","text":"<p>Format: <code>rem rd,rs1,rs2</code></p> <p>Description: Perform an XLEN bits by XLEN bits signed integer reminder of rs1 by rs2.</p> <p>Implementation: <code>x[rd] = x[rs1] %s x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |110  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64m/#remu","title":"remu","text":"<p>Format: <code>remu rd,rs1,rs2</code></p> <p>Description: Perform an XLEN bits by XLEN bits unsigned integer reminder of rs1 by rs2.</p> <p>Implementation: <code>x[rd] = x[rs1] %u x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |111  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64m/#mulw","title":"mulw","text":"<p>Format: <code>mulw rd,rs1,rs2</code></p> <p>Description: Performs multiplication operation on the lower 32 bits of the source registers.</p> <p>Implementation: <code>x[rd] = sext((x[rs1] \u00d7 x[rs2])[31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |000  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64m/#divw","title":"divw","text":"<p>Format: <code>divw rd,rs1,rs2</code></p> <p>Description: Perform an 32 bits by 32 bits signed integer division of rs1 by rs2.</p> <p>Implementation: <code>x[rd] = sext(x[rs1][31:0] /s x[rs2][31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |100  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64m/#divuw","title":"divuw","text":"<p>Format: <code>divuw rd,rs1,rs2</code></p> <p>Description: Perform an 32 bits by 32 bits unsigned integer division of rs1 by rs2.</p> <p>Implementation: <code>x[rd] = sext(x[rs1][31:0] /u x[rs2][31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |101  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64m/#remw","title":"remw","text":"<p>Format: <code>remw rd,rs1,rs2</code></p> <p>Description: Perform an 32 bits by 32 bits signed integer reminder of rs1 by rs2.</p> <p>Implementation: <code>x[rd] = sext(x[rs1][31:0] %s x[rs2][31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |110  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/rv64m/#remuw","title":"remuw","text":"<p>Format: <code>remuw rd,rs1,rs2</code></p> <p>Description: Perform an 32 bits by 32 bits unsigned integer reminder of rs1 by rs2.</p> <p>Implementation: <code>x[rd] = sext(x[rs1][31:0] %u x[rs2][31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|01   |rs2  |rs1  |111  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/","title":"RISC-V RV64I Instruction Set","text":""},{"location":"4-codeGenerator/tmp/#addiw","title":"addiw","text":"<p>Format: <code>addiw rd,rs1,imm</code></p> <p>Description: Adds the sign-extended 12-bit immediate to register rs1 and produces the proper sign-extension of a 32-bit result in rd. Overflows are ignored and the result is the low 32 bits of the result sign-extended to 64 bits. Note, ADDIW rd, rs1, 0 writes the sign-extension of the lower 32 bits of register rs1 into register rd (assembler pseudoinstruction SEXT.W).</p> <p>Implementation: <code>x[rd] = sext((x[rs1] + sext(immediate))[31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |000  |rd   |00110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#slliw","title":"slliw","text":"<p>Format: <code>slliw rd,rs1,shamt</code></p> <p>Description: Performs logical left shift on the 32-bit of value in register rs1 by the shift amount held in the lower 5 bits of the immediate. Encodings with imm[5] \u2260 0 are reserved.</p> <p>Implementation: <code>x[rd] = sext((x[rs1] &lt;&lt; shamt)[31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |shamt|rs1  |001  |rd   |00110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#srliw","title":"srliw","text":"<p>Format: <code>srliw rd,rs1,shamt</code></p> <p>Description: Performs logical right shift on the 32-bit of value in register rs1 by the shift amount held in the lower 5 bits of the immediate. Encodings with imm[5] \u2260 0 are reserved.</p> <p>Implementation: <code>x[rd] = sext(x[rs1][31:0] &gt;&gt;u shamt)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |shamt|rs1  |101  |rd   |00110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sraiw","title":"sraiw","text":"<p>Format: <code>sraiw rd,rs1,shamt</code></p> <p>Description: Performs arithmetic right shift on the 32-bit of value in register rs1 by the shift amount held in the lower 5 bits of the immediate. Encodings with imm[5] \u2260 0 are reserved.</p> <p>Implementation: <code>x[rd] = sext(x[rs1][31:0] &gt;&gt;s shamt)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|00   |shamt|rs1  |101  |rd   |00110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#addw","title":"addw","text":"<p>Format: <code>addw rd,rs1,rs2</code></p> <p>Description: Adds the 32-bit of registers rs1 and 32-bit of register rs2 and stores the result in rd. Arithmetic overflow is ignored and the low 32-bits of the result is sign-extended to 64-bits and written to the destination register.</p> <p>Implementation: <code>x[rd] = sext((x[rs1] + x[rs2])[31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |000  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#subw","title":"subw","text":"<p>Format: <code>subw rd,rs1,rs2</code></p> <p>Description: Subtract the 32-bit of registers rs1 and 32-bit of register rs2 and stores the result in rd. Arithmetic overflow is ignored and the low 32-bits of the result is sign-extended to 64-bits and written to the destination register.</p> <p>Implementation: <code>x[rd] = sext((x[rs1] - x[rs2])[31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|00   |rs2  |rs1  |000  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sllw","title":"sllw","text":"<p>Format: <code>sllw rd,rs1,rs2</code></p> <p>Description: Performs logical left shift on the low 32-bits value in register rs1 by the shift amount held in the lower 5 bits of register rs2 and produce 32-bit results and written to the destination register rd.</p> <p>Implementation: <code>x[rd] = sext((x[rs1] &lt;&lt; x[rs2][4:0])[31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |001  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#srlw","title":"srlw","text":"<p>Format: <code>srlw rd,rs1,rs2</code></p> <p>Description: Performs logical right shift on the low 32-bits value in register rs1 by the shift amount held in the lower 5 bits of register rs2 and produce 32-bit results and written to the destination register rd.</p> <p>Implementation: <code>x[rd] = sext(x[rs1][31:0] &gt;&gt;u x[rs2][4:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |101  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sraw","title":"sraw","text":"<p>Format: <code>sraw rd,rs1,rs2</code></p> <p>Description: Performs arithmetic right shift on the low 32-bits value in register rs1 by the shift amount held in the lower 5 bits of register rs2 and produce 32-bit results and written to the destination register rd.</p> <p>Implementation: <code>x[rd] = sext(x[rs1][31:0] &gt;&gt;s x[rs2][4:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|00   |rs2  |rs1  |101  |rd   |01110|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#lwu","title":"lwu","text":"<p>Format: <code>lwu rd,offset(rs1)</code></p> <p>Description: Loads a 32-bit value from memory and zero-extends this to 64 bits before storing it in register rd.</p> <p>Implementation: <code>x[rd] = M[x[rs1] + sext(offset)][31:0]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |110  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#ld","title":"ld","text":"<p>Format: <code>ld rd,offset(rs1)</code></p> <p>Description: Loads a 64-bit value from memory into register rd for RV64I.</p> <p>Implementation: <code>x[rd] = M[x[rs1] + sext(offset)][63:0]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |011  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sd","title":"sd","text":"<p>Format: <code>sd rs2,offset(rs1)</code></p> <p>Description: Store 64-bit, values from register rs2 to memory.</p> <p>Implementation: <code>M[x[rs1] + sext(offset)] = x[rs2][63:0]</code></p> <p>Encoding: <pre><code>+-----+------+-----+-----+-----+-----------+-----+---+\n|31-27|26-25 |24-20|19-15|14-12|11-7       |6-2  |1-0|\n+-----+------+-----+-----+-----+-----------+-----+---+\n|offset[11:5]|rs2  |rs1  |011  |offset[4:0]|01000|11 |\n+-----+------+-----+-----+-----+-----------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#lui","title":"lui","text":"<p>Format: <code>lui rd,imm</code></p> <p>Description: Build 32-bit constants and uses the U-type format. LUI places the U-immediate value in the top 20 bits of the destination register rd, filling in the lowest 12 bits with zeros.</p> <p>Implementation: <code>x[rd] = sext(immediate[31:12] &lt;&lt; 12)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[31:12]                   |rd   |01101|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#auipc","title":"auipc","text":"<p>Format: <code>auipc rd,imm</code></p> <p>Description: Build pc-relative addresses and uses the U-type format. AUIPC forms a 32-bit offset from the 20-bit U-immediate, filling in the lowest 12 bits with zeros, adds this offset to the pc, then places the result in register rd.</p> <p>Implementation: <code>x[rd] = pc + sext(immediate[31:12] &lt;&lt; 12)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[31:12]                   |rd   |00101|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#addi","title":"addi","text":"<p>Format: <code>addi rd,rs1,imm</code></p> <p>Description: Adds the sign-extended 12-bit immediate to register rs1. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result. ADDI rd, rs1, 0 is used to implement the MV rd, rs1 assembler pseudo-instruction.</p> <p>Implementation: <code>x[rd] = x[rs1] + sext(immediate)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |000  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#slti","title":"slti","text":"<p>Format: <code>slti rd,rs1,imm</code></p> <p>Description: Place the value 1 in register rd if register rs1 is less than the signextended immediate when both are treated as signed numbers, else 0 is written to rd.</p> <p>Implementation: <code>x[rd] = x[rs1] &lt;s sext(immediate)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |010  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sltiu","title":"sltiu","text":"<p>Format: <code>sltiu rd,rs1,imm</code></p> <p>Description: Place the value 1 in register rd if register rs1 is less than the immediate when both are treated as unsigned numbers, else 0 is written to rd.</p> <p>Implementation: <code>x[rd] = x[rs1] &lt;u sext(immediate)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |011  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#xori","title":"xori","text":"<p>Format: <code>xori rd,rs1,imm</code></p> <p>Description: Performs bitwise XOR on register rs1 and the sign-extended 12-bit immediate and place the result in rd. Note, \"XORI rd, rs1, -1\" performs a bitwise logical inversion of register rs1(assembler pseudo-instruction NOT rd, rs)</p> <p>Implementation: <code>x[rd] = x[rs1] ^ sext(immediate)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |100  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#ori","title":"ori","text":"<p>Format: <code>ori rd,rs1,imm</code></p> <p>Description: Performs bitwise OR on register rs1 and the sign-extended 12-bit immediate and place the result in rd</p> <p>Implementation: <code>x[rd] = x[rs1] | sext(immediate)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |110  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#andi","title":"andi","text":"<p>Format: <code>andi rd,rs1,imm</code></p> <p>Description: Performs bitwise AND on register rs1 and the sign-extended 12-bit immediate and place the result in rd</p> <p>Implementation: <code>x[rd] = x[rs1] &amp; sext(immediate)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|imm[11:0]        |rs1  |111  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#slli","title":"slli","text":"<p>Format: <code>slli rd,rs1,shamt</code></p> <p>Description: Performs logical left shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate. In RV64, bit-25 is used to shamt[5].</p> <p>Implementation: <code>x[rd] = x[rs1] &lt;&lt; shamt</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|0X   |shamt|rs1  |001  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#srli","title":"srli","text":"<p>Format: <code>srli rd,rs1,shamt</code></p> <p>Description: Performs logical right shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate. In RV64, bit-25 is used to shamt[5].</p> <p>Implementation: <code>x[rd] = x[rs1] &gt;&gt;u shamt</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|0X   |shamt|rs1  |101  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#srai","title":"srai","text":"<p>Format: <code>srai rd,rs1,shamt</code></p> <p>Description: Performs arithmetic right shift on the value in register rs1 by the shift amount held in the lower 5 bits of the immediate. In RV64, bit-25 is used to shamt[5].</p> <p>Implementation: <code>x[rd] = x[rs1] &gt;&gt;s shamt</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|0X   |shamt|rs1  |101  |rd   |00100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#add","title":"add","text":"<p>Format: <code>add rd,rs1,rs2</code></p> <p>Description: Adds the registers rs1 and rs2 and stores the result in rd. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result.</p> <p>Implementation: <code>x[rd] = x[rs1] + x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |000  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sub","title":"sub","text":"<p>Format: <code>sub rd,rs1,rs2</code></p> <p>Description: Subs the register rs2 from rs1 and stores the result in rd. Arithmetic overflow is ignored and the result is simply the low XLEN bits of the result.</p> <p>Implementation: <code>x[rd] = x[rs1] - x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|00   |rs2  |rs1  |000  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sll","title":"sll","text":"<p>Format: <code>sll rd,rs1,rs2</code></p> <p>Description: Performs logical left shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2.</p> <p>Implementation: <code>x[rd] = x[rs1] &lt;&lt; x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |001  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#slt","title":"slt","text":"<p>Format: <code>slt rd,rs1,rs2</code></p> <p>Description: Place the value 1 in register rd if register rs1 is less than register rs2 when both are treated as signed numbers, else 0 is written to rd.</p> <p>Implementation: <code>x[rd] = x[rs1] &lt;s x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |010  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sltu","title":"sltu","text":"<p>Format: <code>sltu rd,rs1,rs2</code></p> <p>Description: Place the value 1 in register rd if register rs1 is less than register rs2 when both are treated as unsigned numbers, else 0 is written to rd.</p> <p>Implementation: <code>x[rd] = x[rs1] &lt;u x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |011  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#xor","title":"xor","text":"<p>Format: <code>xor rd,rs1,rs2</code></p> <p>Description: Performs bitwise XOR on registers rs1 and rs2 and place the result in rd</p> <p>Implementation: <code>x[rd] = x[rs1] ^ x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |100  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#srl","title":"srl","text":"<p>Format: <code>srl rd,rs1,rs2</code></p> <p>Description: Logical right shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2</p> <p>Implementation: <code>x[rd] = x[rs1] &gt;&gt;u x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |101  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sra","title":"sra","text":"<p>Format: <code>sra rd,rs1,rs2</code></p> <p>Description: Performs arithmetic right shift on the value in register rs1 by the shift amount held in the lower 5 bits of register rs2</p> <p>Implementation: <code>x[rd] = x[rs1] &gt;&gt;s x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|01000|00   |rs2  |rs1  |101  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#or","title":"or","text":"<p>Format: <code>or rd,rs1,rs2</code></p> <p>Description: Performs bitwise OR on registers rs1 and rs2 and place the result in rd</p> <p>Implementation: <code>x[rd] = x[rs1] | x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |110  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#and","title":"and","text":"<p>Format: <code>and rd,rs1,rs2</code></p> <p>Description: Performs bitwise AND on registers rs1 and rs2 and place the result in rd</p> <p>Implementation: <code>x[rd] = x[rs1] &amp; x[rs2]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |rs2  |rs1  |111  |rd   |01100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#fence","title":"fence","text":"<p>Format: <code>fence pred, succ</code></p> <p>Description: Used to order device I/O and memory accesses as viewed by other RISC-V harts and external devices or coprocessors. Any combination of device input (I), device output (O), memory reads (R), and memory writes (W) may be ordered with respect to any combination of the same. Informally, no other RISC-V hart or external device can observe any operation in the successor set following a FENCE before any operation in the predecessor set preceding the FENCE.</p> <p>Implementation: <code>Fence(pred, succ)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-28|27-24|23-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|0000 |pred |succ |00000|000  |00000|00011|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#fencei","title":"fence.i","text":"<p>Format: <code>fence.i</code></p> <p>Description: Provides explicit synchronization between writes to instruction memory and instruction fetches on the same hart.</p> <p>Implementation: <code>Fence(Store, Fetch)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |00000|00000|001  |00000|00011|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#csrrw","title":"csrrw","text":"<p>Format: <code>csrrw rd,offset,rs1</code></p> <p>Description: Atomically swaps values in the CSRs and integer registers. CSRRW reads the old value of the CSR, zero-extends the value to XLEN bits, then writes it to integer register rd. The initial value in rs1 is written to the CSR. If rd=x0, then the instruction shall not read the CSR and shall not cause any of the side effects that might occur on a CSR read.</p> <p>Implementation: <code>t = CSRs[csr]; CSRs[csr] = x[rs1]; x[rd] = t</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|csr              |rs1  |001  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#csrrs","title":"csrrs","text":"<p>Format: <code>csrrs rd,offset,rs1</code></p> <p>Description: Reads the value of the CSR, zero-extends the value to XLEN bits, and writes it to integer register rd. The initial value in integer register rs1 is treated as a bit mask that specifies bit positions to be set in the CSR. Any bit that is high in rs1 will cause the corresponding bit to be set in the CSR, if that CSR bit is writable. Other bits in the CSR are unaffected (though CSRs might have side effects when written).</p> <p>Implementation: <code>t = CSRs[csr]; CSRs[csr] = t | x[rs1]; x[rd] = t</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|csr              |rs1  |010  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#csrrc","title":"csrrc","text":"<p>Format: <code>csrrc rd,offset,rs1</code></p> <p>Description: Reads the value of the CSR, zero-extends the value to XLEN bits, and writes it to integer register rd. The initial value in integer register rs1 is treated as a bit mask that specifies bit positions to be cleared in the CSR. Any bit that is high in rs1 will cause the corresponding bit to be cleared in the CSR, if that CSR bit is writable. Other bits in the CSR are unaffected.</p> <p>Implementation: <code>t = CSRs[csr]; CSRs[csr] = t &amp;\u223cx[rs1]; x[rd] = t</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|csr              |rs1  |011  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#csrrwi","title":"csrrwi","text":"<p>Format: <code>csrrwi rd,offset,uimm</code></p> <p>Description: Update the CSR using an XLEN-bit value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field encoded in the rs1 field.</p> <p>Implementation: <code>x[rd] = CSRs[csr]; CSRs[csr] = zimm</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|csr              |uimm |101  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#csrrsi","title":"csrrsi","text":"<p>Format: <code>csrrsi rd,offset,uimm</code></p> <p>Description: Set CSR bit using an XLEN-bit value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field encoded in the rs1 field.</p> <p>Implementation: <code>t = CSRs[csr]; CSRs[csr] = t | zimm; x[rd] = t</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|csr              |uimm |110  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#csrrci","title":"csrrci","text":"<p>Format: <code>csrrci rd,offset,uimm</code></p> <p>Description: Clear CSR bit using an XLEN-bit value obtained by zero-extending a 5-bit unsigned immediate (uimm[4:0]) field encoded in the rs1 field.</p> <p>Implementation: <code>t = CSRs[csr]; CSRs[csr] = t &amp;\u223czimm; x[rd] = t</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|csr              |rs1  |111  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#ecall","title":"ecall","text":"<p>Format: <code>ecall</code></p> <p>Description: Make a request to the supporting execution environment. When executed in U-mode, S-mode, or M-mode, it generates an environment-call-from-U-mode exception, environment-call-from-S-mode exception, or environment-call-from-M-mode exception, respectively, and performs no other operation.</p> <p>Implementation: <code>RaiseException(EnvironmentCall)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |00000|00000|000  |00000|11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#ebreak","title":"ebreak","text":"<p>Format: <code>ebreak</code></p> <p>Description: Used by debuggers to cause control to be transferred back to a debugging environment. It generates a breakpoint exception and performs no other operation.</p> <p>Implementation: <code>RaiseException(Breakpoint)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |00001|00000|000  |00000|11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#uret","title":"uret","text":"<p>Format: <code>uret</code></p> <p>Description: Return from traps in U-mode, and URET copies UPIE into UIE, then sets UPIE.</p> <p>Implementation: <code>ExceptionReturn(User)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00000|00   |00010|00000|000  |00000|11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sret","title":"sret","text":"<p>Format: <code>sret</code></p> <p>Description: Return from traps in S-mode, and SRET copies SPIE into SIE, then sets SPIE.</p> <p>Implementation: <code>ExceptionReturn(User)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00010|00   |00010|00000|000  |00000|11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#mret","title":"mret","text":"<p>Format: <code>mret</code></p> <p>Description: Return from traps in M-mode, and MRET copies MPIE into MIE, then sets MPIE.</p> <p>Implementation: <code>ExceptionReturn(Machine)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00110|00   |00010|00000|000  |00000|11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#wfi","title":"wfi","text":"<p>Format: <code>wfi</code></p> <p>Description: Provides a hint to the implementation that the current hart can be stalled until an interrupt might need servicing. Execution of the WFI instruction can also be used to inform the hardware platform that suitable interrupts should preferentially be routed to this hart. WFI is available in all privileged modes, and optionally available to U-mode. This instruction may raise an illegal instruction exception when TW=1 in mstatus.</p> <p>Implementation: <code>while (noInterruptsPending) idle</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00010|00   |00101|00000|000  |00000|11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sfencevma","title":"sfence.vma","text":"<p>Format: <code>sfence.vma rs1,rs2</code></p> <p>Description: Guarantees that any previous stores already visible to the current RISC-V hart are ordered before all subsequent implicit references from that hart to the memory-management data structures. The SFENCE.VMA is used to flush any local hardware caches related to address translation. It is specified as a fence rather than a TLB flush to provide cleaner semantics with respect to which instructions are affected by the flush operation and to support a wider variety of dynamic caching structures and memory-management schemes. SFENCE.VMA is also used by higher privilege levels to synchronize page table writes and the address translation hardware.</p> <p>Implementation: <code>Fence(Store, AddressTranslation)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|00010|01   |rs2  |rs1  |000  |rd   |11100|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#lb","title":"lb","text":"<p>Format: <code>lb rd,offset(rs1)</code></p> <p>Description: Loads a 8-bit value from memory and sign-extends this to XLEN bits before storing it in register rd.</p> <p>Implementation: <code>x[rd] = sext(M[x[rs1] + sext(offset)][7:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |000  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#lh","title":"lh","text":"<p>Format: <code>lh rd,offset(rs1)</code></p> <p>Description: Loads a 16-bit value from memory and sign-extends this to XLEN bits before storing it in register rd.</p> <p>Implementation: <code>x[rd] = sext(M[x[rs1] + sext(offset)][15:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |001  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#lw","title":"lw","text":"<p>Format: <code>lw rd,offset(rs1)</code></p> <p>Description: Loads a 32-bit value from memory and sign-extends this to XLEN bits before storing it in register rd.</p> <p>Implementation: <code>x[rd] = sext(M[x[rs1] + sext(offset)][31:0])</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |010  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#lbu","title":"lbu","text":"<p>Format: <code>lbu rd,offset(rs1)</code></p> <p>Description: Loads a 8-bit value from memory and zero-extends this to XLEN bits before storing it in register rd.</p> <p>Implementation: <code>x[rd] = M[x[rs1] + sext(offset)][7:0]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |100  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#lhu","title":"lhu","text":"<p>Format: <code>lhu rd,offset(rs1)</code></p> <p>Description: Loads a 16-bit value from memory and zero-extends this to XLEN bits before storing it in register rd.</p> <p>Implementation: <code>x[rd] = M[x[rs1] + sext(offset)][15:0]</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |101  |rd   |00000|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sb","title":"sb","text":"<p>Format: <code>sb rs2,offset(rs1)</code></p> <p>Description: Store 8-bit, values from the low bits of register rs2 to memory.</p> <p>Implementation: <code>M[x[rs1] + sext(offset)] = x[rs2][7:0]</code></p> <p>Encoding: <pre><code>+-----+------+-----+-----+-----+-----------+-----+---+\n|31-27|26-25 |24-20|19-15|14-12|11-7       |6-2  |1-0|\n+-----+------+-----+-----+-----+-----------+-----+---+\n|offset[11:5]|rs2  |rs1  |000  |offset[4:0]|01000|11 |\n+-----+------+-----+-----+-----+-----------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sh","title":"sh","text":"<p>Format: <code>sh rs2,offset(rs1)</code></p> <p>Description: Store 16-bit, values from the low bits of register rs2 to memory.</p> <p>Implementation: <code>M[x[rs1] + sext(offset)] = x[rs2][15:0]</code></p> <p>Encoding: <pre><code>+-----+------+-----+-----+-----+-----------+-----+---+\n|31-27|26-25 |24-20|19-15|14-12|11-7       |6-2  |1-0|\n+-----+------+-----+-----+-----+-----------+-----+---+\n|offset[11:5]|rs2  |rs1  |001  |offset[4:0]|01000|11 |\n+-----+------+-----+-----+-----+-----------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#sw","title":"sw","text":"<p>Format: <code>sw rs2,offset(rs1)</code></p> <p>Description: Store 32-bit, values from the low bits of register rs2 to memory.</p> <p>Implementation: <code>M[x[rs1] + sext(offset)] = x[rs2][31:0]</code></p> <p>Encoding: <pre><code>+-----+------+-----+-----+-----+-----------+-----+---+\n|31-27|26-25 |24-20|19-15|14-12|11-7       |6-2  |1-0|\n+-----+------+-----+-----+-----+-----------+-----+---+\n|offset[11:5]|rs2  |rs1  |010  |offset[4:0]|01000|11 |\n+-----+------+-----+-----+-----+-----------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#jal","title":"jal","text":"<p>Format: <code>jal rd,offset</code></p> <p>Description: Jump to address and place return address in rd.</p> <p>Implementation: <code>x[rd] = pc+4; pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[20|10:1|11|19:12]     |rd   |11011|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#jalr","title":"jalr","text":"<p>Format: <code>jalr rd,rs1,offset</code></p> <p>Description: Jump to address and place return address in rd.</p> <p>Implementation: <code>t =pc+4; pc=(x[rs1]+sext(offset))&amp;\u223c1; x[rd]=t</code></p> <p>Encoding: <pre><code>+-----+-----+-----+-----+-----+-----+-----+---+\n|31-27|26-25|24-20|19-15|14-12|11-7 |6-2  |1-0|\n+-----+-----+-----+-----+-----+-----+-----+---+\n|offset[11:0]     |rs1  |000  |rd   |11001|11 |\n+-----+-----+-----+-----+-----+-----+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#beq","title":"beq","text":"<p>Format: <code>beq rs1,rs2,offset</code></p> <p>Description: Take the branch if registers rs1 and rs2 are equal.</p> <p>Implementation: <code>if (x[rs1] == x[rs2]) pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+---------+-----+-----+-----+--------------+-----+---+\n|31-27|26-25    |24-20|19-15|14-12|11-7          |6-2  |1-0|\n+-----+---------+-----+-----+-----+--------------+-----+---+\n|offset[12|10:5]|rs2  |rs1  |000  |offset[4:1|11]|11000|11 |\n+-----+---------+-----+-----+-----+--------------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#bne","title":"bne","text":"<p>Format: <code>bne rs1,rs2,offset</code></p> <p>Description: Take the branch if registers rs1 and rs2 are not equal.</p> <p>Implementation: <code>if (x[rs1] != x[rs2]) pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+---------+-----+-----+-----+--------------+-----+---+\n|31-27|26-25    |24-20|19-15|14-12|11-7          |6-2  |1-0|\n+-----+---------+-----+-----+-----+--------------+-----+---+\n|offset[12|10:5]|rs2  |rs1  |001  |offset[4:1|11]|11000|11 |\n+-----+---------+-----+-----+-----+--------------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#blt","title":"blt","text":"<p>Format: <code>blt rs1,rs2,offset</code></p> <p>Description: Take the branch if registers rs1 is less than rs2, using signed comparison.</p> <p>Implementation: <code>if (x[rs1] &lt;s x[rs2]) pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+---------+-----+-----+-----+--------------+-----+---+\n|31-27|26-25    |24-20|19-15|14-12|11-7          |6-2  |1-0|\n+-----+---------+-----+-----+-----+--------------+-----+---+\n|offset[12|10:5]|rs2  |rs1  |100  |offset[4:1|11]|11000|11 |\n+-----+---------+-----+-----+-----+--------------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#bge","title":"bge","text":"<p>Format: <code>bge rs1,rs2,offset</code></p> <p>Description: Take the branch if registers rs1 is greater than or equal to rs2, using signed comparison.</p> <p>Implementation: <code>if (x[rs1] &gt;=s x[rs2]) pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+---------+-----+-----+-----+--------------+-----+---+\n|31-27|26-25    |24-20|19-15|14-12|11-7          |6-2  |1-0|\n+-----+---------+-----+-----+-----+--------------+-----+---+\n|offset[12|10:5]|rs2  |rs1  |101  |offset[4:1|11]|11000|11 |\n+-----+---------+-----+-----+-----+--------------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#bltu","title":"bltu","text":"<p>Format: <code>bltu rs1,rs2,offset</code></p> <p>Description: Take the branch if registers rs1 is less than rs2, using unsigned comparison.</p> <p>Implementation: <code>if (x[rs1] &lt;u x[rs2]) pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+---------+-----+-----+-----+--------------+-----+---+\n|31-27|26-25    |24-20|19-15|14-12|11-7          |6-2  |1-0|\n+-----+---------+-----+-----+-----+--------------+-----+---+\n|offset[12|10:5]|rs2  |rs1  |110  |offset[4:1|11]|11000|11 |\n+-----+---------+-----+-----+-----+--------------+-----+---+\n</code></pre></p>"},{"location":"4-codeGenerator/tmp/#bgeu","title":"bgeu","text":"<p>Format: <code>bgeu rs1,rs2,offset</code></p> <p>Description: Take the branch if registers rs1 is greater than or equal to rs2, using unsigned comparison.</p> <p>Implementation: <code>if (x[rs1] &gt;=u x[rs2]) pc += sext(offset)</code></p> <p>Encoding: <pre><code>+-----+---------+-----+-----+-----+--------------+-----+---+\n|31-27|26-25    |24-20|19-15|14-12|11-7          |6-2  |1-0|\n+-----+---------+-----+-----+-----+--------------+-----+---+\n|offset[12|10:5]|rs2  |rs1  |111  |offset[4:1|11]|11000|11 |\n+-----+---------+-----+-----+-----+--------------+-----+---+\n</code></pre></p>"},{"location":"5-errorHandling/errorHandlingNotes/","title":"Error Handling Documentation","text":""},{"location":"5-errorHandling/errorHandlingNotes/#overview","title":"Overview","text":"<p>Our compiler's error handling consists of two main components:</p> <ol> <li>Syntax Error Handling: Enhances ANTLR's default syntax error messages with more helpful, Rust-style formatting</li> <li>Semantic Error Handling: Implements custom semantic analysis with detailed error reporting</li> </ol> <p>The compiler processes syntax first, then semantics. If any errors are detected at either stage, compilation stops.</p>"},{"location":"5-errorHandling/errorHandlingNotes/#syntax-error-handling","title":"Syntax Error Handling","text":""},{"location":"5-errorHandling/errorHandlingNotes/#how-it-works","title":"How It Works","text":"<p>The <code>NewSyntaxErrorHandler</code> intercepts ANTLR's syntax errors and reformats them to be more user-friendly. The handler:</p> <ol> <li>Captures the error location (line and column)</li> <li>Retrieves the source code line where the error occurred</li> <li>Categorizes the error type based on the error message</li> <li>Generates a formatted error message with visual indicators</li> </ol>"},{"location":"5-errorHandling/errorHandlingNotes/#example","title":"Example","text":"<p>For an input like:</p> <pre><code>int main() {\n  int x = 5\n  return x;\n}\n</code></pre> <p>Instead of a generic ANTLR message like:</p> <pre><code>line 3:2 missing ';' at 'return'\n</code></pre> <p>Our formatter produces:</p> <pre><code>line 2:10\n  int x = 5\n          ^\nSyntax Error: missing ';' at end of declaration\n</code></pre>"},{"location":"5-errorHandling/errorHandlingNotes/#error-categories","title":"Error Categories","text":"<p>The syntax error handler recognizes several common error patterns:</p> <ul> <li>Missing braces and brackets</li> <li>Missing semicolons</li> <li>Invalid identifiers</li> <li>Unexpected type keywords</li> <li>Mismatched parentheses</li> <li>Incomplete array declarations</li> </ul>"},{"location":"5-errorHandling/errorHandlingNotes/#semantic-error-handling","title":"Semantic Error Handling","text":""},{"location":"5-errorHandling/errorHandlingNotes/#how-it-works_1","title":"How It Works","text":"<p>Since ANTLR doesn't handle semantic analysis, we implement our own semantic analyzer that:</p> <ul> <li>Index out of bound</li> <li>Divide by zero</li> <li>Type mismatch:</li> <li>Assignment type mismatch</li> <li>Function return type mismatch</li> <li>Operator type mismatch</li> <li>Function argument type mismatch</li> <li>Invalid function:</li> <li>Argument count mismatch</li> <li>Undefined symbol</li> <li>Variable out of scope</li> </ul> <p>The <code>NewSemanticErrorFormatter</code> then formats these errors in a consistent style.</p>"},{"location":"5-errorHandling/errorHandlingNotes/#example_1","title":"Example","text":"<p>For input like:</p> <pre><code>int main() {\n  int x = 10;\n  bool y = x + 5;\n  return y;\n}\n</code></pre> <p>Our semantic analyzer would produce:</p> <pre><code>line 3:12\n  bool y = x + 5;\n            ^\nSemantic Error: type mismatch: expected bool, got int\n</code></pre>"},{"location":"5-errorHandling/errorHandlingNotes/#error-detection-features","title":"Error Detection Features","text":"<p>The semantic error formatter includes specialized handling for:</p> <ul> <li>Function argument count mismatches</li> <li>Return type mismatches</li> <li>Array access on non-array types</li> <li>Undefined symbols</li> <li>Type compatibility errors</li> <li>Invalid operator usage</li> </ul>"},{"location":"5-errorHandling/errorHandlingNotes/#error-reporting-flow","title":"Error Reporting Flow","text":"<ol> <li>Source code is parsed by ANTLR with our custom <code>NewSyntaxErrorFormatter</code></li> <li>If syntax is valid, our semantic analyzer checks for semantic errors</li> <li>All errors are formatted in a consistent style and reported to the user</li> <li>Compilation stops if any errors are found at either stage</li> </ol> <p>Source code repo: https://github.com/GoBigC/BigC/tree/main/pkg/error_formatter </p>"},{"location":"6-builtinFunctions/builtin/","title":"Built-in Functions","text":"<p>BigC provides basic builtin functions for printing output to console.</p>"},{"location":"6-builtinFunctions/builtin/#list-of-builtins","title":"List of builtins","text":"<ol> <li><code>_printInt()</code></li> <li><code>_printFloat()</code></li> <li><code>_printBool()</code></li> <li><code>_printChar()</code></li> </ol>"},{"location":"6-builtinFunctions/builtin/#how-are-builtins-implemented","title":"How are builtins implemented?","text":"<p>BigC provides built-in functions in the most naive, simple way possible:</p> <ul> <li>Each builtin function is hand-written in assembly</li> <li>Before generate user code, generate all builtin functions at the top of the assembly code file</li> </ul> <p>It doesn't get much stupider than that. But if it works, it works.</p> <p>This way of builtin support also means that the builtin functions will bypass Syntax Analyzer and Semantic Analyzer. Bypassing these phases means losing most of the error-catching mechanisms. Losing error-catching mechanisms means these builtin functions have no room for error.</p> <p>To resolve this, we chose a skinny interface.</p>"},{"location":"6-builtinFunctions/builtin/#builtin-interface","title":"Builtin interface","text":"<p>All _printX() functions assume the thing to be printed is already loaded at the correct register:</p> <ul> <li><code>_printFloat()</code> will print the item in register <code>fa0</code></li> <li>all other print functions will print the item in register <code>a0</code></li> </ul> <p>This is a skinny interface, as it is not flexible and require the setup to be right to function correctly. So:</p> <ul> <li>As language developer: If the thing you want to print is not in these registers, it is your responsibility to load it to the expected register.</li> <li>As language user: If the language developers do their job right, you should not have to care about this.</li> </ul>"}]}