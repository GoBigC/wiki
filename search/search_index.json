{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BigC Documentation","text":"<p>BigC is a compiled programming language that's not as big as C.</p>"},{"location":"contributing/","title":"Want to contribute to BigC?","text":"<p>It's all here, clone, fork, whatever you want! </p>"},{"location":"faq/","title":"FAQ","text":"<ol> <li>Who are the authors? </li> <li>@siddankthep (Sid) - Farmer #1 </li> <li>@lanphgphm (LP) - Farmer #2</li> <li> <p>@esp-khoap (Khoa) - Farmer #3</p> </li> <li> <p>Why?  N/A</p> </li> <li> <p>Why the broccoli logo?  We were originally called \"TheBroccoliFarmers\", but had to change the organization's name due to practicality. </p> </li> </ol>"},{"location":"0-housekeeping/","title":"BigC Documentation","text":"<p>BigC is a compiled programming language that's not as big as C.</p> <ul> <li> <p>Language design choices</p> <ul> <li>A compiled language</li> <li>Compiles to RISC-V assembly</li> <li>Arguments are Pass-By-Value</li> <li>Compiler written in Go</li> </ul> </li> <li> <p>Tech stack</p> <ul> <li>ANTLR </li> <li>Go </li> <li>RISC-V assembly</li> </ul> </li> </ul>"},{"location":"0-housekeeping/designChoices/","title":"BigC Is a Compiled Language","text":"<p>The choice to write a compiled language as opposed to an interpreted one is mostly because we wanted to write a compiler. </p> <p>As hardwares get more and more powerful, the previously slow execution time of a code snippet is hardly noticeable anymore. Languages that spawned recently are mostly compiled for this reason:</p> <p></p> <p>We think that we have significantly more chance to write interpreted languages in future work experiences, and we wanted to take this chance to know what it takes to write a compiled language. </p>"},{"location":"0-housekeeping/designChoices/#targets-the-risc-v-isa","title":"Targets the RISC-V ISA","text":"<p>Compiling from a high-level language to another high-level language (like C or Java, or god forbid, Python) seems like cheating :) as if it is pseudo-compiling :) </p> <p>So to put ourselves to the challenge, we decided to compile our language to an assembly language.</p> <p>So why RISC-V? </p> <p>It seems like a rising ISA and we want to know what's up :D It's also always a good use of time to learn assembly (right?)</p>"},{"location":"0-housekeeping/designChoices/#function-arguments-are-pass-by-value","title":"Function Arguments are Pass-By-Value","text":"<p>This choice was made out of practicality: Pass-By-Reference is hard :) and we believe that to do a good job at it, we need to know how to implement Pass-By-Value anyways. </p> <p>To get this project started, we were advised to only supports Pass-By-Value. </p>"},{"location":"0-housekeeping/designChoices/#compiler-written-in-go","title":"Compiler Written In Go","text":"<p>Because many companies are writing or even rewriting their tools in Go. Most recently Microsoft decided to write their TypeScript engine in Go (see here). </p> <p>And once again, we'd like to know why the language is so loved :)</p>"},{"location":"0-housekeeping/techStack/","title":"Why ANTLR?","text":"<p>If not ANTLR, we would be working with lex/yacc (flex/bison), which would generate C codes, and it takes an extra step to make that compatible with Go code. The general advice we see is that if we don't have to use lex/yacc (ie. maintaining a legacy compiler that uses these), then we should look for different tools(source1), (source2).</p> <p> </p> <p>Go has its own version of yacc called goyacc. It is very close to yacc, but native to Go. And by translation, the previous warnings about using lex/yacc still kinda applies. </p> <p>ANTLR is more modern and supports Go. ANTLR also supports the Visitor pattern out of the box. For this and the fact that people warns so much against lex/yacc, we made the decision to use ANTLR as BigC's parser generator.</p> <p>Since ANTLR is a LL-parser, we should make our grammar not left-recursive.  </p>"},{"location":"0-housekeeping/techStack/#why-go","title":"Why Go?","text":"<p>Because we want to.</p>"},{"location":"0-housekeeping/techStack/#why-risc-v","title":"Why RISC-V?","text":"<p>Because we want to. </p>"},{"location":"1-grammar/","title":"Grammar","text":"<ul> <li>BigC's full grammar</li> <li>Proof of unambiguity</li> <li>Sample code snippets</li> </ul>"},{"location":"1-grammar/bible/","title":"BigC Full Grammar","text":""},{"location":"1-grammar/proof/","title":"Proof of Unambiguity","text":""},{"location":"1-grammar/sample/","title":"Sample BigC Code","text":""},{"location":"2-syntaxAnalyzer/","title":"Syntax Analysis","text":"<ul> <li>Lexical Analysis </li> <li>Parsing </li> <li>Semantic Analysis</li> </ul> <p>The first two are done using ANTLR. </p>"},{"location":"2-syntaxAnalyzer/interface/","title":"Syntax Analyzer Interface","text":"<p>| Input | BigC source code | | Output | Abstract Syntax Tree |</p>"},{"location":"3-semanticAnalyzer/","title":"Syntax Analysis","text":"<ul> <li>Static data typing </li> <li>Static variable scoping </li> </ul>"},{"location":"3-semanticAnalyzer/interface/","title":"Semantic Analysis Interface","text":"<p>| Input | Abstract Syntax Tree | | Output | Annotated Abstract Syntax Tree (with typing &amp; scoping) |</p>"},{"location":"4-codeGenerator/","title":"Code Generation","text":"<p>Generates RISC-V assembly. </p>"},{"location":"4-codeGenerator/interface/","title":"Code Generator Interface","text":"<p>| Input | Annotated Abstract Syntax Tree |  | Output | RISC-V assembly |</p>"}]}