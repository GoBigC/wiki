{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About BigC","text":"<p>BigC is a compiled programming language that's not as big as C.</p> <ul> <li> <p>Language design choices</p> <ul> <li>A compiled language</li> <li>Compiles to RISC-V assembly</li> <li>Arguments are Pass-By-Value</li> <li>Compiler written in Go</li> </ul> </li> <li> <p>Tech stack</p> <ul> <li>ANTLR </li> <li>Go </li> <li>RISC-V assembly</li> </ul> </li> </ul>"},{"location":"contributing/","title":"Want to contribute to BigC?","text":"<p>It's all here, clone, fork, whatever you want! </p>"},{"location":"faq/","title":"FAQ","text":"<ol> <li> <p>Who are the authors? </p> <ul> <li>@siddankthep (Sid) - Farmer #1 </li> <li>@lanphgphm (LP) - Farmer #2</li> <li>@esp-khoap (Khoa) - Farmer #3</li> </ul> </li> <li> <p>Why? </p> </li> </ol> <p>N/A</p> <ol> <li>Why the broccoli logo? </li> </ol> <p>We were originally called \"TheBroccoliFarmers\", but had to change the organization's name due to practicality. </p> <ol> <li>Why BigC? </li> </ol> <p>Because we think it's funny. </p>"},{"location":"0-housekeeping/designChoices/","title":"BigC Is a Compiled Language","text":"<p>The choice to write a compiled language as opposed to an interpreted one is mostly because we wanted to write a compiler. </p> <p>As hardwares get more and more powerful, the previously slow execution time of a code snippet is hardly noticeable anymore. Languages that spawned recently are mostly compiled for this reason:</p> <p></p> <p>We think that we have significantly more chance to write interpreted languages in future work experiences, and we wanted to take this chance to know what it takes to write a compiled language. </p>"},{"location":"0-housekeeping/designChoices/#static-typing-static-scoping","title":"Static Typing &amp; Static Scoping","text":"<p>For safety and predictability, BigC requires explicit typing that will be checked during compilation. </p> <p>Dynamic scoping is generally not a good idea, though it makes things simpler for us language developers. Dynamically scoped languages like JavaScript or Bash are often used to write short scripts, and that is not the intended direction for BigC. </p>"},{"location":"0-housekeeping/designChoices/#targets-the-risc-v-isa","title":"Targets the RISC-V ISA","text":"<p>Compiling from a high-level language to another high-level language (like C or Java, or god forbid, Python) seems like cheating :) as if it is pseudo-compiling :) </p> <p>So to put ourselves to the challenge, we decided to compile our language to an assembly language.</p> <p>So why RISC-V? </p> <p>It seems like a rising ISA and we want to know what's up :D It's also always a good use of time to learn assembly (right?)</p>"},{"location":"0-housekeeping/designChoices/#function-arguments-are-pass-by-value","title":"Function Arguments are Pass-By-Value","text":"<p>This choice was made out of practicality: Pass-By-Reference is hard :) and we believe that to do a good job at it, we need to know how to implement Pass-By-Value anyways. </p> <p>To get this project started, we were advised to only supports Pass-By-Value. </p>"},{"location":"0-housekeeping/designChoices/#compiler-written-in-go","title":"Compiler Written In Go","text":"<p>Because many companies are writing or even rewriting their tools in Go. Most recently Microsoft decided to write their TypeScript engine in Go (see here). </p> <p>And once again, we'd like to know why the language is so loved :)</p>"},{"location":"0-housekeeping/techStack/","title":"Why ANTLR?","text":"<p>If not ANTLR, we would be working with lex/yacc (flex/bison), which would generate C codes, and it takes an extra step to make that compatible with Go code. The general advice we see is that if we don't have to use lex/yacc (ie. maintaining a legacy compiler that uses these), then we should look for different tools(source1), (source2).</p> <p> </p> <p>Go has its own version of yacc called goyacc. It is very close to yacc, but native to Go. And by translation, the previous warnings about using lex/yacc still kinda applies. </p> <p>ANTLR is more modern and supports Go. ANTLR also supports the Visitor pattern out of the box. For this and the fact that people warns so much against lex/yacc, we made the decision to use ANTLR as BigC's parser generator.</p> <p>Since ANTLR is a LL-parser, we should make our grammar not left-recursive. See more in the ANTLR lexer document</p>"},{"location":"0-housekeeping/techStack/#why-go","title":"Why Go?","text":"<p>Because we want to. </p> <p>Actually, because recently Microsoft port their entire Typescript engine into Go, which is such a big egoless move, and we thought Go must be really good for people at Microsoft to do this. We too would like to know why Go is rising so fast. </p>"},{"location":"0-housekeeping/techStack/#why-risc-v","title":"Why RISC-V?","text":"<p>Because we want to. </p>"},{"location":"1-grammar/bible/","title":"BigC Full Grammar","text":"<p>This wiki page consolidates all grammar rules into one place for easy lookup, but in reality we split the grammar into multiple files for better focus and maintenance. Go to code repository.</p>"},{"location":"1-grammar/bible/#parser-rules","title":"Parser Rules","text":"<p>program     : declaration* EOF      ; </p> <p>declaration     : constDeclaration     | type Identifier declarationRemainder      ; </p> <p>type     : 'int'     | 'float'     | 'bool'     | 'char'     | 'void'      ; </p> <p>constDeclaration     : 'const' type Identifier '=' expression ';'     ;</p> <p>declarationRemainder      : '(' parameterList? ')' block      | Identifier variableInitializer? ';'     ; </p> <p>variableInitializer     : '=' expression ';'     ;</p> <p>parameterList     : parameter (',' parameter)*     ; </p> <p>parameter     : type Identifier     ;</p> <p>block      : '{' blockItem* '}'     ; </p> <p>blockItem     : declaration     | statement     ; </p> <p>statement     : ifStatement     | nonIfStatement     ; </p> <p>ifStatement     : 'if' '(' expression ')' block elseBlock?     ;</p> <p>elseBlock     : 'else' elseBlockRemainder      ; </p> <p>elseBlockRemainder      : block      | ifStatement      ; </p> <p>nonIfStatement      : expression ';'     | whileStatement     | returnStatement     ;</p> <p>whileStatement     : 'while' '(' expression ')' block      ; </p> <p>returnStatement      : 'return' expression ';'     ; </p> <p>expression      : assignmentExpression      ; </p> <p>assignmentExpression     : logicalOrExpression ('=' assignmentExpression)?     ; </p> <p>logicalOrExpression     : logicalAndExpression ('||' logicalAndExpression)*     ; </p> <p>logicalAndExpression     : equalityExpression ('&amp;&amp;' equalityExpression)*     ; </p> <p>equalityExpression     : comparisonExpression (equalityOperator comparisonExpression)*     ; </p> <p>equalityOperator      : '=='     | '!='     ; </p> <p>comparisonExpression      : additionExpression (comparisonOperator additionExpression)*      ; </p> <p>comparisonOperator     : '&gt;'     | '&lt;'     | '&gt;='     | '&lt;='     ; </p> <p>additionExpression     : multiplicationExpression (addSubtractOperator multiplicationExpression)*     ; </p> <p>addSubtractOperator      : '+'     | '-'     ; </p> <p>multiplicationExpression     : unaryExpression (multDivModOperator unaryExpression)*     ; </p> <p>multDivModOperator     : '*'     | '/'     | '%'     ; </p> <p>unaryExpression      : postfixExpression      | unaryOperator unaryExpression      ; </p> <p>unaryOperator     : '++' // prefix     | '--' // prefix     ;</p> <p>postfixExpression      : primaryExpression (arrayAccess | functionCallArgs | increaseDecrease)*     ; </p> <p>arrayAccess      : '[' expression ']'     ; </p> <p>functionCallArgs     : '(' argList? ')'     ; </p> <p>increaseDecrease     : '++'  // postfix     | '--'  // postfix      ; </p> <p>argList      : assignmentExpression (',' assignmentExpression)*     ; </p> <p>primaryExpression      : Identifier      | constant      | '(' expression ')'     ; </p> <p>constant     : IntegerConstant      | FloatingConstant      | BooleanConstant      | CharConstant      ; </p>"},{"location":"1-grammar/bible/#lexer-rules","title":"Lexer Rules","text":"<p>Identifier     : [a-zA-Z_][a-zA-Z0-9]*     ; </p> <p>IntegerConstant     : [0-9]+     ;</p> <p>FloatingConstant     : [0-9]+ '.' [0-9]+     ; </p> <p>CharConstant     : '\\'' ~[\\r\\n]'\\'' // anything but CR, LF     ;</p> <p>BooleanConstant      : 'true'     | 'false'     ; </p> <p>WS     : [ \\t\\r\\n]+ -&gt; skip     ; </p> <p>COMMENT     : '//' ~[\\r\\n]* -&gt; skip     ; </p> <p>DOCSTRING     : '/' .? '*/' -&gt; skip      ; </p>"},{"location":"1-grammar/proof/","title":"Proof of Unambiguity","text":"<p>A grammar is considered unambiguous if it is LL(1) or LR(1), meaning the parser can determine the exact rule to apply next by examining only one token ahead in the input stream. In the same sense, the more tokens a parser needs to lookahead, the more ambiguous the grammar is. </p> <p>The proof of BigC's grammar unambiguity is therefore done by using ANTLR. ANTLR writes logs for each production rules it consume, and if the rule is unambiguous, it marks this rule to be <code>LL(1)? true</code>. When all rules/decisions in the grammar is marked like this, we say that the entire grammar is unambiguous. </p> <p>You can read the log here to verify that BigC has an unambiguous grammar: </p> <pre><code>DECISION 0 in rule program\n2025-03-26 06:55:54:419 LL1 LogManager.java:25 look=[{4..8}, &lt;EOF&gt;]\n2025-03-26 06:55:54:419 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:419 LL1 LogManager.java:25 \n\nDECISION 1 in rule assignmentExpression\n2025-03-26 06:55:54:419 LL1 LogManager.java:25 look=[2, {3, 10, 12, 15}]\n2025-03-26 06:55:54:419 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:419 LL1 LogManager.java:25 \n\nDECISION 2 in rule postfixExpression\n2025-03-26 06:55:54:419 LL1 LogManager.java:25 look=[9, 11, {13..14}, {2..3, 10, 12, 15..28}]\n2025-03-26 06:55:54:419 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 \n\nDECISION 3 in rule functionCallArgs\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 look=[{11, 13..14, 35..39}, 12]\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 \n\nDECISION 4 in rule argList\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 look=[15, 12]\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 \n\nDECISION 5 in rule primaryExpression\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 look=[35, {36..39}, 11]\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 \n\nDECISION 6 in rule logicalOrExpression\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 look=[16, {2..3, 10, 12, 15}]\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 \n\nDECISION 7 in rule logicalAndExpression\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 look=[17, {2..3, 10, 12, 15..16}]\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 \n\nDECISION 8 in rule equalityExpression\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 look=[{18..19}, {2..3, 10, 12, 15..17}]\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 \n\nDECISION 9 in rule comparisonExpression\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 look=[{20..23}, {2..3, 10, 12, 15..19}]\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:420 LL1 LogManager.java:25 \n\nDECISION 10 in rule additionExpression\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 look=[{24..25}, {2..3, 10, 12, 15..23}]\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 \n\nDECISION 11 in rule multiplicationExpression\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 look=[{26..28}, {2..3, 10, 12, 15..25}]\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 \n\nDECISION 12 in rule unaryExpression\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 look=[{11, 35..39}, {13..14}]\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 \n\nDECISION 13 in rule statement\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 look=[29, {11, 13..14, 33..39}]\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 \n\nDECISION 14 in rule ifStatement\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 look=[30, {4..8, 11, 13..14, 29, 32..39}]\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 \n\nDECISION 15 in rule elseClause\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 look=[31, 29]\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 \n\nDECISION 16 in rule declarationRemainder\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 look=[{4..8}, 12]\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 \n\nDECISION 17 in rule declarationRemainder\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 look=[2, 3]\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:421 LL1 LogManager.java:25 \n\nDECISION 18 in rule declarationRemainder\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 look=[11, 35]\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 \n\nDECISION 19 in rule parameterList\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 look=[15, 12]\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 \n\nDECISION 20 in rule block\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 look=[{4..8, 11, 13..14, 29, 33..39}, 32]\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 \n\nDECISION 21 in rule blockItem\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 look=[{4..8}, {11, 13..14, 29, 33..39}]\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 LL(1)? true\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 \n\nDECISION 22 in rule nonIfStatement\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 look=[{11, 13..14, 35..39}, 33, 34]\n2025-03-26 06:55:54:422 LL1 LogManager.java:25 LL(1)? true\n</code></pre>"},{"location":"1-grammar/sample/","title":"Sample BigC Code","text":""},{"location":"2-syntaxAnalyzer/interface/","title":"Syntax Analyzer Interface","text":"<ul> <li>Input: BigC source code </li> <li>Output: Abstract Syntax Tree </li> </ul> <p>Source code repo: https://github.com/GoBigC/syntaxAnalyzer </p>"},{"location":"3-semanticAnalyzer/interface/","title":"Semantic Analysis Interface","text":"<ul> <li>Input: Abstract Syntax Tree </li> <li>Output: Annotated Abstract Syntax Tree (with typing &amp; scoping) </li> </ul> <p>Source code repo: https://github.com/GoBigC/semanticAnalyzer </p>"},{"location":"4-codeGenerator/interface/","title":"Code Generator Interface","text":"<ul> <li>Input: Annotated Abstract Syntax Tree </li> <li>Output: RISC-V assembly</li> </ul> <p>Source code repo: https://github.com/GoBigC/codeGenerator </p>"}]}